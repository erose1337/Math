Polar coordinates v Cartesian coordinates
=========================================


        y
        /\
        |    a
        |- -/- -
        |- / - -
    |==>|-/- - -
    |   |/ - - -
    |   0---------->x
    |          /\
    +----------||
            "basis" or "reference"

Polar coordinates
-----------------
- measurements given in (degrees, length)
- measurements given in:
   - angle between line and one axis from basis/reference
        - Is there a notion of angle between line and > one axis?
   - length of the line:
        - sqrt(x^2 + y^2) (euclidean norm, distance from 0)
- Do polar coordinates have a norm?

Cartesian coordinates
---------------------
- measurements given in (x, y)
- measurements given in:
    - length of line along one axis of the basis/reference
    - length of line along another axis of the basis/reference


Xor and And with polynomials where x > 2
========================================

- Compute exclusive-or on polynomials `x^a + x^b + x^c ...`
    - Same as when x=2, just evaluated as below:
        if a_1 == a_2:
            y^a = 0
        else:
            y^a = 1
    - Properties:
        -

- Compute `and` on polynomials
    if a_1 == a_2 and a_1 > 0:
        y_a = a_1
    else:
        y_a = 0








subset sum signature scheme
===========================

distribute set of ciphertexts as public key

sign:
    - hash message
    - use bits of hash to select elements of set to sum
    - decrypt sum
        - yields a preimage that sums to sum, but is not the hash of the message
    - distribute message/hash and alternative preimage signature `s`

verify:
    - hash message
    - check that the hash does not equal the signature
    - use bits of hash to select elements of set to sum (sum1)
    - use bits of signature to select elements of set to sum (sum2)
    - output True if sum1 == sum2







These use pickle.load(s)
- Cookie
- Google keyring
- 2to3
- bsddb







Information and Questions
====================================


there exists a set of information related to the question
there exists a subset of that information helpful in answering the question





Is there some kind of turing-equivalence notion for proof languages?
What is the smallest number of axioms you can use to prove anything any other equivalent language could prove?
Is there a hierarchy of statements/languages, where languages that can be used to prove a statement overlap (like complexity theory for proofs)




IBE
===
is it possible to securely authenticate a peer if only a username is known?
    - possible without trusted third parties ("TTPs")?
        - possible without TTPs being all-knowing?
        - possible without TTPs being a single point of failure?
        - possible without TTPs knowing what peer is authenticating what other peer?






z = sqrt(x^2 + y^2) mod P
distance from 0, mod P?









L2 Norm
=======

f(a, b) -> sqrt(a^2 + b^2)

What properties do norms have?

What shape does x = f(a, b) produce for natural numbers x?








Sampling
========

Recording
---------
- find next peak or valley
- record (absolute) max height
   - could take the point with the largest height
   - could average nearby values

Playback
--------
- take in two points from the input samples (point_a and point_b)
- repeat until all points are used:
   - push point_a onto the output stack
   - draw a curve between them and push some number of points from the curve onto the output stack
   - push point_b onto the output stack
   - set point_a = point_b
   - set point_b = next point from the input samples









Units in sums of two squares
============================
(a^2 + b^2) * (c^2 + d^2) is equal to a sum of two squares
Are there sums of two squares that are not the product of two sums of two squares?
    Do they behave as fundamental units, e.g. "primes"
        given such a "unit", can you use it to make all other elements?







The set of all information exists
The simplest operation is `copy`
    - e.g. basis of life is self-replication, an organism creating copies of itself is a pattern of information making copies of itself
    - `copy` is the same thing as `mov`
        - `mov` is arguably mis-named
- mechanisms for storage of information needed

Expressive programming language
===============================
- use case (bold, italic, normal) to indicate meaning
- =? as comparison operator?
- for name/type declaration, use:

    for a vector v, scalar s, type x, ..., :


    Class_Name
    ==========
    - attribute: value

    method_name
    -----------
    -



Pickle Investigation
====================

- Crawl repos on github for python modules
    - find places in code where pickle.load or pickle.loads are called
    - mark as potentially exploitable
        - determine if exploitable
- Create dependency tree of exploitable modules

- Check if program in dependency tree

- Determine target programs list of dependencies
    - Check if dependency

Pride
=====

auto_unschedule
---------------
- indicate which attributes are instructions that should be unscheduled upon deletion







LLL
===
LLL tends to output elements that are roughly the same size
If the value it is looking for is larger than the size of those chunks, you can break it up into pieces at the cost of adding more columns
Can you use a large enough modulus and a sufficiently small target vector to increase the number of columns needed to perform the attack to a prohibitive amount?




what is the minimal algebra that can be used for DH?
what is the simplest algebra that can be used for cryptography?
are there algebras that are too simple to use for any cryptography?
are there algebras that have too many properties for use with cryptography?





=========================
computing N! modulo N + 1

                     (1 + 2 + 3 + ... N)
- N! mod (N + 1) = g^                   mod (N + 1)
    - where g is a generator
        - a generator can be found using the factorization of N + 1

- Can test if N is prime if N + 1 can be factored in acceptable time
    - a randomly selected number is probably not a worst-case instance of the factoring problem
        - n is a factor of every n numbers
        - a randomly selected number has a 1/x chance of having x as a factor
        - probability that none of the first x numbers divide n:
            - p = 1/2 * 2/3 * 3/4 * 4/5 * ... * (x-1)/x
        - probability that at least one of the first k primes divides n:
            - 1.0 - p
- Begin factoring N and N + 1
- If factoring N finishes first, then use the factorization to determine primality
- If factoring N + 1 finishes first, then use the factorization to compute N! mod (N + 1)
- probability that neither (random) N or N + 1 have any of the first k primes as factors: 1/p^2


def prime_test(n):
    n1 = n + 1
    g = find_generator(n1)
    x = tri(n)
    if pow(g, x, n1) == 1:
        return True

def find_generator(n):
    factorization = factor_integer(n)
    g = use_factorization_to_find_generator(n, factorization)
    return g

def use_factorization_to_find_generator(n, prime_factors):
    size = int(log(n, 2) * 8)
    while True:
        candidate = random_integer(size) % n # biased, but probably fine
        for prime in prime_factors:
            b = pow(candidate, n / prime, n + 1)
            if b == 1:
                break
        else:
            #outputs = []
            #for x in range(n):
            #    gx = pow(candidate, x, n + 1)
            #    print("Testing if g^{} in outputs already".format(x))
            #    if gx in outputs:
            #        print len(set(outputs)), outputs, gx, n
            #        raise ValueError("Did not find correct generator")
            #    outputs.append(gx)
            #print("Found generator for {}".format(n))
            return candidate




# for x, y such that f(x) = y
#   draw the line from (x, 0) to (0, y)
# examine result for congruences and relationships
import pride.gui.themes
import pride.gui.gui
class Graph_Theme(pride.gui.themes.Theme):

    def draw_texture(self):
        x_offset, y_offset, x_max, y_max = self.area
        x_scalar = x_max / len(self.inputs)
        y_scalar = y_max / len(self.outputs)
        y_axis = y_offset + y_max
        line_color = self.glow_color
        draw = self.draw
        for x, y in zip(self.inputs, self.outputs):
            draw("line", x_offset + (x_scalar * x), y_axis,
                         x_offset, y_axis - (y_scalar * y),
                 color=line_color)

class Function_Graph(pride.gui.gui.window):
    defaults = {"inputs" : tuple(), "outputs" : tuple(),
                "theme_type" : Graph_Theme}


Currency that disincentives hoarding
====================================
- Design a currency that makes hoarding large amounts of money infeasible, impractical, inconvenient, and not cost-effective
    - Require significant financial investment to hold on to a unit of currency
    - Spending should be easy, convenient, and inexpensive
        - e.g. no added charges beyond the value of an item purchased (tax)


Large space requirement to hold a currency unit
-----------------------------------------------
- e.g. storing n units requires 2^n space
- Requires hardware and maintenance, or a subscription to a service that provides them
- Requires redundancy for reliable long-term storage
- Requires power
    - How does it compare to the power used by large time requirements?
- Implies large bandwidth cost to transfer a currency unit


Large time requirement to hold a currency unit
----------------------------------------------
- e.g. storing n units requires 2^n time
- Requires increasingly expensive hardware to evaluate 2^n operations in convenient time for larger n
- Requires power
    - How does it compare to the power used by large space requirements?


Value is related to density
---------------------------
- Denser currency units have a larger value/space ratio
    - Example with arbitrary values: a 1-unit requires 2^1 space (1/2 = .5), but a 10-unit requires 2^11 space (10/512 = .019)
- For a given amount of space, it is more efficient to hold lower-valued units rather than higher-valued units
    - Using the same numbers from above
        - 2^11 space could hold 11 1-units (total value: 11 * 1 = 11)
        - 2^11 space could hold  1 10-unit (total value: 1 * 10 = 10)



Chording Keyboard
=================
- Converts a normal keyboard into programmable chording keyboard
    - Pressing multiple keys simultaneously allows to select from 2^n different possible states, where n is the number of possible keys
    - Enables "pass-chords" e.g. password, passphrase, passchords
- Can make compatible with regular keyboard by simply not registering chord presses with any callback

Mode Toggle
-----------
- Press mode: pressing a key turns the state on, and releasing a key turns the state off
- Hold mode: pressing and releasing a key swaps the off/on state of the key

When is a key press registered and acted upon?
----------------------------------------------
- Normally this happens when a key is released
    - Try: When a key is released, use all currently pressed keys to determine state, then release the key
        - ignore the next release of all keys that are still pressed

    Layout
    ======
    - Put more common/helpful items in more accessible areas
    - Assuming a qwerty-layout keyboard
        Option 1
        --------
            Home Row
            --------
            - 9 Instantly accessible keys
            - asdf jkl; and the space bar
            Extended Home Row
            -----------------
            - 14 Easily accessible keys
            - Includes the characters from Home Row, plus CAPS LOCK ' and enter/return
        Option 2
        --------
        - keep fingers in constant arrangement as in asdf jkl;
            - fingers simply resting straight across
        - move up and down rows as needed, while retaining straight across arrangement of fingers
        - In one row, there are 2^9 (512) instantly accessible states

Hold keys to select a category
    - Use "sustain" key to "turn on" pressed keys, so that they stay held after being released by the operator
Press keys to select an entry in that category
    - Accumulate key presses that are held longer than x seconds
    - Act on key presses that are held less than x seconds


Analog table look-up
====================
- use transformer to implement a key:value lookup


Are key:value stores "complete"?
================================
- Can you use them to implement any function


Sequences
===================
- A sequence X is an ordered collection of data
    - f(i), f(j), ..., f(k)
    - X_i, X_j, ..., X_k
- The length of a sequence X is denoted |X| and is equal the number of samples in the sequence
- Two sequences are equivalent if |X| == |Y| and X_i == Y_i for all i
- A subsequence of X is a sequence Y such that X_i == Y_0, X_(i+1) == Y_1, ..., X_(i+j) == Y_|Y| for 0 < i < |X|
    - X contains Y
    - Y is in X
        X = 0 1 2 3 4 5 6 7 8 9
        Y = 0 1 2 3 4
        Z = 5 6 7 8 9
        Y is a subsequence of X
        Z is a subsequence of X

Operations and their relations
------------------------------
- Concatenation X || Y
    - Example:
        X = 0 1 2 3
        Y = 4 5 6 7 8 9
     X||Y = ___________
          = 0 1 2 3 4 5 6 7 8 9
    - non-commutative
        - equivalent to X + (Y * 2^k)
    - There exist A, B such that A || B != B || A
        - Property still occurs in some quantity of A, B of a given length (what quantity?)
    - Inverse: Slice

- Slice X[x:y] for sequence X and (optional) scalars x, y
    - If x is not specified, x=0 is implied
    - If y is not specified, y=|X| is implied
    - returns the subsequence X_i for i in range(x, y)
    - Example:
            X = 0 1 2 3
            Y = 0 1 2 3 4 5 6 7 8 9
       Y[|X|:]= ___________________
                4 5 6 7 8 9
    - X[:-|Y|] removes the last |Y| entries from X
        - X[:-|Y|] is the inverse of X || Y


- X % Y = X_i for all i if X_i != Y_i else 0
    - |X % Y| = |X|
- X ?? Y is equal to the number of times the sequence Y appears in X
- X / Y is equal to X with all copies of the subsequence Y removed
        (X || Y || Y || Z || Y || Z) / Y
      =  X || Z || z
    - Y is a factor of X if Y is a subsequence of X
- X ?? y for a sequence X and scalar y is equal to X + X + ... + X, for y terms
        X_0, ..., X_|X|, X_0, ..., X_|X|, X_0, ..., X_|X|  ...
              1                2                3
- X * Y for two sequences X, Y is equal to X_0 + Y + X_1 + Y + ... + X_|X| + Y
    - interleaves copies of Y into samples of X
- XY for two sequences X, Y is equal to X_0 + Y_0 + X_1 + Y_1 + ... + X_|Y| + Y_|Y| + X_(|Y| + 1) + ... + X_|X|
    - interleaves samples of Y into samples of X
#- The weight of a sequence X is the number of non-zero entries in X
#    - |X_i for all i if X_i != 0|

Polynomial Equivalent operations
----------------------
- A sequence X can be represented by a polynomial of the form
        2^(w*0)*X_0 + 2^(w*1)*X_1 + 2^(w*2)*X_2 + ... 2^(w*i)*X_|X|
        a^0 * X_0 + a^1 * X_1 + a^2 * X_2 + ... + a^|X| * X_|X|
  where w is the word size of the alphabet
    - or numerical base
        - "A sequence X can be represented by a polynomial of the form

            w = w^0, w^1, ... w^i
            s = s_0, s_1, ..., s_i
            X = dot_product(s, w)
              = (s_0 * w^0) + (s_1 * w^1) + ... + (s_i * w_i)

            where:
                - `w` is for "width", the number base or the size of the set of all symbols in the alphabet
                    - The w vector provides the "shape", it aligns the symbols of the sequence one after another with no overlap
                - 's' is for "symbols"
                    - The s vector provides the elements of the sequence
                - The dot_product takes the elements of the

- Sum X + Y is equal to X_0 + Y_0, X_1 + Y_1, ... X_min(|X|, |Y|) + Y_min(|X|, |Y|)
        X = 0 0 0 0 4 5 6 7 8 9
        Y = 0 1 2 3
         X+Y = ___________________
            0 1 2 3 4 5 6 7 8 9

- Difference X - Y is equal to X_0 - Y_0, X_1 - Y_1, ..., X_min(|X|, |Y|), Y_min(|X|, |Y|)
    X = 0 1 2 3 4 5 6 7 8 9
    Y = 0 0 0 0 4 5 6 7 8 9
      -____________________
      = 0 1 2 3

- X_i * y for an element of a sequence X_i and a scalar y is equal to the product of the value of X_i with y
- X * y for a sequence X and scalar y is equal to X_0 * y, X_1 * y, ..., X_|X| * y
- X_i * Y for an element of a sequence X_i and a sequence Y is equal to
        (a^i * X_i) * (a^0 * Y_0 + ...  + a^|Y| * Y_|Y|)
         (a^i * a^0 * X_i * Y_0) + (a^i * a^1 * X_i * Y_1) + ... + (a^i * a^|Y| * X_i * Y_|Y|)
- X * Y for two sequences X, Y is equal to  X_0 * Y, X_1 * Y, ..., X_|X| * Y
(x^2y + x^1z)(x^2a + xb)


- Length |X| = log(X, b), for a base

The concatenation operation
---------------------------
- concatenation, denoted by `X || Y`, is a function on two sequences that outputs one sequence
    - |(X || Y)| = |X| + |Y|
        - The length of the concatenation of X and Y is equal to the length of X plus the length of Y
        -
    `f(X, Y) -> X + (w^|X| * Y)`

where `'0'` denotes the "zero" sequence

    `w^|X|` is the

    `shift = |X|`

- forms a group?
    - inverse element:
        (X || Y) || -Y = X + (w^|X| * Y) + (w^|X| * (-1 * Y)) = X
    - if Y == X, then the operation is commutative
    - if Y != X, then the operation is non-commutative


Compress
--------
- Look for all identical sequences of length |input|/2 ... 1
    - Store sequence:occurrences pairs
    - store f(i), ..., f(j) in the common data section
    - push an index to the sequences location in the common data section onto the data stack section
- Look for sequences










"Has the property of" rather than "is"
======================================





ROL with modular arithmetic
===========================
rotate_left(x, k, n, b): (x / b^k) + (x * b^(n - k))
rotate_right(x, k, n, b): (x * b^k) + (x / b^(n - k))
- x: number to be rotated
- k: shift magnitude, the amount of rotation
- n: word size, the number of points on the regular n-gon
- b: number base, binary, ternary, octal, decimal, hex, etc
    - only examined with b=2 so far

- Can you use this to actually track rotation about a circle rather than using it to do bitwise rotation?
- Can you use bitwise rotation to efficiently track rotation about a circle?

- Application to group theory?
    a = g^x mod p
    g^(x + 1) mod p == rotate_left(a, 1, p, g)
        - faster to multiply by g than to use rotate_left
        - g^x * g = rotate_left(g^x, 1, p, g)
                  = (x / b^k) + (x * b^(n - k)) # substitute definition of rotate_left
                  = (x / g^1) + (x * g^(p - 1)) # substitute parameter names and values (k->1, n->p, b->g)
                  = (x / g) + (x * 1)           # substitute g for g^1, 1 for g^(p - 1)
                  = x/g + x
                  = x(1/g + 1)






Solve discrete logarithm problem by solving subset product
==================================
- Discrete logarithm problem: Given, g, P, g^x mod P, output x
- x = (a_k * 2^k) + (a_k-1 * 2^(k-1)) + ... + (a_0 * 2^0)
    - where a is a vector with coefficients in (0, 1)
- Given the set g^(2^k), g^(2^(k-1)), ..., g^(2^0) and target g^x, output the vector a
- Difficulty is determined by:
    - the size of `x`
        - determines the number of elements in the set
        - private exponent may be selected as much smaller than size of the group (e.g. 256 bits)
    - weight(a) (number of non-zero entries in the target vector a)
        - determines the number of elements in the subset
        - is centered around k / 2
    - density?
        - For the subset sum problem, density is defined as
            number of elements in the set
            -----------------------------
              log2(largest item in set)
        - Density very near 1.0 makes the problem hard
            - Low and High density instances can be solved easily

        -(Unsure) In this case, density = k/log2(g^(2^k))
            - For a 256-bit exponent:
                - k = 256
                - g=2 implies log2(largest item in set) = 2^k?
                - k/(2^k) is extremely small?
            - log2(g^(2^k)) is probably log2(P) sized
                - if P is 2048 bits, then density = 256/2048 = .125
                - if P is 1024 bits, then density = 256/1024 = .250
    - https://cstheory.stackexchange.com/a/36155/53055

        > The meet in the middle approaches that work in subset sum and k-sum should also work here with slight modifications.
        > It can be solved in O~(nm/2) by constructing two lists L1 and L2 where L1 is all possible products from first m/2 lists and L2 is all possible products for last m/2 lists.

- Difficulty: O(2^(log2(x)/4)) ?
    - log2(x) / 2 is the worst-case weight of x
        - if weight is larger, then the subset inverse-product problem can be solved instead, where the operator is replaced with the operators inverse (e.g. subset sum -> subset difference)
    - log2(x) / 4 is the worst-case weight of x, divided by two
        - division by two from partitioning/meet in the middle attack ?
    - O(2^(256 / 4)) == O(2^64)


Determine function from a sequence
==================================
- e.g. (1, 3, 5, 7, ...)
    - easy for humans to extrapolate that the sequence is "increasing odd numbers"
        - f(x) -> 0x + 1
    - Given a sequence, what process will determine a function that generates it?
        - Take difference of successive entries



"Natural" Norm
==============
- for a vector v
- f(v) = vector whose elements represent the distance from v_i to the closet natural (or integer) number
    - k_i = |round(v_i) - v_i|
        - 0 <= k_i <= 1/2
            - k_i = 0 if v_i is an natural (or integer)
            - k_i = 1/2 if v_i = x + 1/2 = (x + 1) - 1/2
- norm = max(f(v))
- if norm = 0, then all entries in v are natural (or integer) numbers


Group Theory, The Regular n-gon, and weight-1 binary words modulo 2^n
================================================
- A group of order n can be represented by a regular n-gon
- An element of that group can be represented by a vertice (point) on that n-gon
    - This perspective is equivalent to a weight 1 binary sequence modulo 2^(n)
        - The vertice representing the group element is equivalent to a '1' bit
        - The vertices not representing the group element are equivalent to '0' bits
    - The "increment" group operation is equivalent to the rotation of a weight-1 binary word modulo 2^n
        - e.g. g * g = g^(1 + 1) = g^2
    - The "decrement" group operation is equivalent to the opposite rotation of a weight-1 binary word modulo 2^n
        - e.g. g * 1/g = g^(1 - 1) = g^0 = 1
    - Could alternatively select edges (lines) instead of vertices to use as representation; there are equal number of both in a regular n-gon

Possibly useful:
----------------
- From wikipedia https://en.wikipedia.org/wiki/Regular_polygon:
    - For a regular n-gon inscribed in a unit-radius circle:
        - the product of the distances from a given vertex to all other vertices (including adjacent vertices and vertices connected by a diagonal) equals n

    - For a regular convex n-gon, each interior angle has a measure of:
        - 180(n - 2) / n degrees
        - (n - 2)/2n turns

- Can you tile a the regular n-gon into some other shape that is convenient for analysis?




Do comparisons use short-circuit evaluation? e.g.:

    def greater_than(x, y):
        for index, x_bit in enumerate(x):
            y_bit = y[index]
            if x_bit:
                if not y_bit:
                    return True
            elif y_bit:
                return False
        return False

    - If so, can this be used to mount a timing attack?









          X   Y   Z   T   ...
velocity
position
spin
repulsion











psuedo 3d via point perspective
-------------------------------
place 4 vanishing points at 0, 90, 180, 270 degrees (every 1/4 turn of a circle)
set field of view to (initial, initial + increment)
    - e.g. initial = 0
    - increment controls number of selectable points
        - #points = 90/increment

mouse motion on the selected axis rotates the field of view by increasing or decreasing the values of the field of view








**import** module **for** methods
=========================
- Syntax:
    ```python
import module for method, constant, variable, ...
import module for *```

- specifies which content from the module will actually be used
- not allowing access to other content could be enforced
    ```python
import module for x
module.y # raises Exception```
- accessing other content can be assumed not to happen
    - can import only the content that is used and store it locally






> given a,b,c ∈ N, determine whether ax^2 + by − c = 0 has a solution x,y ∈ N

- is an NP-Complete problem
- from https://cstheory.stackexchange.com/a/14147/53055

ax^2 + by − c = 0
ax^2 + by = c

m := b
r := a

rx^2 + my = c





Distributive search through all combinations of expressions
===========================================================
- generate or select an expression
    - generate finds a new expression to evaluate for relationships
        for function_number, variables, operators in zip(isequence, all_variable_combinations, all_operator_combinations):
            function = form_expression(variables, operators)
            yield function_number, function
    - or can generate a new combination at random
        - useful for exploring larger and more complex expressions
    - generate combinations of pre-existing expressions:
        for function_number, expressions, operators in zip(isequence, all_expression_combinations, all_operator_combinations):
            function = form_expression(expressions, operators)
            yield function_number, function
            # a real function_number will need a more complex format to distinguish between different entries from different generators that share a given expression_number

    - select examines an already known expression from storage
        - retrieve from storage (e.g. database, distributed hash table, etc)

- search for expressions by specifying relations and constraints
    - query storage for all expressions with a given relation

- analyze an expression to determine what properties it has
    - try applying all known (relevant) interfaces first, in order of most common
        - finds already known structure s(e.g. groups) relatively quickly
    - is there a way to start without relying on built-in known properties?
        - What is a property?
            - A statement involving variables that can be evaluated to obtain a binary conclusion
            - e.g. (from https://en.wikipedia.org/wiki/Group_(mathematics) )
                - Closure: For all a, b in G, the result of the operation, a • b, is also in G

                    def closure(f, all_element_pairs_generator, G):
                        for a, b in all_element_pairs_generator:
                            if f(a, b) not in G:
                                return False
                        return True

                - Associativity: For all a, b and c in G, (a • b) • c = a • (b • c).

                    def associativity(f, all_element_triplets_generator, G):
                        for a, b, c in all_element_triplets_generator:
                            if f(f(a  b), c) != f(a * f(b * c)):
                                return False
                        return True
                - etc
        - How to generate properties?
            - Generate increasingly complex combinations of statements from qualifiers, functions, and in(equality(ies))
                - for x, y, z in set_generator
                - there exists x, y, z
                - such that ...boolean_statement... (and) ...boolean_statement...
                    - example boolean_statement: f(a, b) in G

        - How to prune redundant properties?
            - some properties might be the same as another, just in a different form
            - when a new relation is discovered, see if it is equivalent to any other relations
                - would need to be done periodically


- search for relationships that are implied by the composition of combinations of known relations
    - e.g. "all objects that have property a and b have property c"
           "there is no object that has property c and not have properties a, b"


Expressions as Sequences
========================
- examine/define expressions e.g. `a + b = c` in terms of Sequences
    - Sequence: sum((b^i) * symbol for i, symbol in enumerate(expression))
        - symbol is the natural number encoding of an element in an alphabet or language
        - b is the base, that represents the size of the alphabet |alphabet|
            - The size of the alphabet is the number of symbols it contains




Slideshow background
====================
randomly select pictures from somewhere and display them as a slideshow
    - e.g. wikipedia (wikimedia?)



Are there objects that do not possess a given relation as a whole, but a significant subset of such objects does possess that relation?
    - e.g. The concatenation function f(x, y) is non-commutative in general, but becomes commutative when y = x






Qualities of Music
==================

Primary
-------
- a sequence of tones and/or chords
- rhythm
- Primary qualities mostly determine what "being the same song" means


Secondary
---------
- volume
- tempo
- sequence
- staccato
- legato
- tapping
- swells
- arpeggio
- Effects in general
- Secondary qualities determine the qualities of a given instance of a piece of music


"Intrinsic" versus "Extrinsic" aspects of music
===============================================
- The intrinsic qualities of a piece of music are:
- Intrinsic qualities are "stored"
    - "determined at compile time"



- The extrinsic qualities of a piece of music are:
    - variations in:
        - it's a noisy universe, there will always be some deviation from exact, though it may be small
        - Every instance of a given piece will always be unique from every other instance
            - small chance for noise to cancel out
- Extrinsic qualities occur while the piece is being played
    - "determined at runtime"










except Exception from ...
=========================

    except Exception from interaction_regarding_name:
        # "interaction_regarding_name" e.g.:
        #   a[b]
        #   a(b)

    except KeyError from "self._value_map[value]":

    except Exception from callable
    except Exception from object








"Length" and "Angle" (or "Length" and "Trig" ? ) (or "Ruler" and "Compass" ? )
====================
- a + b(i^(x mod k))
    - a is the length of a straight line
    - bi^(x mod k) is the angular or phase component
        - b is the radius of the curve
        - i^(x mod k) is the phase
            - `i` is the phase unit
            - `k` is the number of equally spaced points on the edge of a circle
                - k = 4 is the "imaginary unit" used with "complex numbers"
                - larger `k`s provide "higher resolution"
            - x is a point on the edge of a circle
            - (x mod k) is a finite ... group? ring? field?
- "Complex numbers" seem to be able to










What attack models exist, and when/why are they relevant
========================================================
- Note: This section currently only discusses encryption and confidentiality
    - There are other attack models for authentication, integrity, MACs, and digital signatures

Attack models
-------------
- An attack model specifies what abilities and information the adversary is assumed to have access to

Indistinguishability
--------------------
- Models the










Good Ideas
==========
- Users post ideas that they think are good, but will not have time/resources to realize on their own
- Different categories of ideas (e.g. software, games, story ideas)
    - Should have a dedicated humor category/tag
- Users vote on the quality of ideas
- Users can discuss, comment on, and make suggestions to improve a given idea
- "Implementations" page that shows examples of people who took the idea and realized it
    - Can vote on the quality of an implementation


Cop Rank
========
- "Social credit" score to motivate officers to pursue peaceful, non-violent solutions that help the people they interact with
- After an interaction with a police officer(s), the participating parties submit a review of their experience with the officer(s)
    - + points for positive interactions
        - Motivation: Rewards for being a good officer?
    - - points for negative interactions
        - Motivation: Aversion towards being a notorious police officer
        - e.g. murder of civilians garners an extreme amount of negative points


n-tau, The Shape Constant
=========================
- generalization of 2pi to regular n-gons
    - n-tau = perimeter / diameter
    - infinity-tau = pi



p^2 = 24n + 1
if sqrt(24n + 1) is a natural number, is it necessarily prime?
    - No; see primalitytest3.py







Symbolic Solving Strategies
===========================
- set expression equal to zero
- factor the expression if possible
    - x^2 - y^2 = (x + y) * (x - y)
    `0 = x^2 - 1
       = (x + 1) * (x - 1)
       = (x^2 - x + x - 1)
       = (x^2         - 1
       = x^2 - 1


        x^2 - 4               = x^2 - y^2
        (x + 2) * (x - 2)     = (x + y) * (x - y)
        (x^2 - 2x + 2x - 4)   = (x^2 - xy + xy - y^2)
        (x^2 - 4)             = (x^2 - y^2)
- linearize terms
- re-write variables in terms of other variables
    - if gcd(a, b) > 1, ax + by = ax + acy = a(x + cy)
    - x = (y * 2^k) + z  (break into two pieces; the most-significant and least-significant bits)



Could a polynomial-cost SAT solver be used to learn information about the structure of existence?



What is the cost of solving a subset-sum problem over an elliptic curve?




public information:
  - The generator: G
  - The sequence: 2^0, 2^1, ..., 2^n
  - The sequence: 2^0 G, 2^1 G, ..., 2^n G (multiply prior sequence by G)
      - Referred to as "the set"
  - x = 2^i, 2^j, ..., 2^k
      - alternatively written as: 2^i + 2^j + ... + 2^k
      - alternatively written as the inner product of 2^0, 2^1, ..., 2^n with i, j, ..., k where {i, j, k in (0, 1)}
      - Referred to as "the subset" or "the solution vector"
  - x G = (2^i + 2^j + ... + 2^k)G
goal:
  - Given x G, output x
  - Given the set, find a subset that sums to x G
  - Given the set as a vector `a` (e.g. `a = sorted(the set)`) and the inner product `y = a*x` find the binary vector `x`
      - The inner product of two vectors is denoted *






From: https://en.wikipedia.org/wiki/Additive_number_theory#Additive_number_theory

> For example, Vinogradov proved that every sufficiently large odd number is the sum of three primes,
> and so every sufficiently large even integer is the sum of four primes.
> Hilbert proved that, for every integer k > 1, every nonnegative integer is the sum of a bounded number of k-th powers.

From: https://en.wikipedia.org/wiki/Goldbach%27s_conjecture

> Every even integer greater than 2 can be expressed as the sum of two primes.
> Every integer greater than 5 can be written as the sum of three primes.

From: https://en.wikipedia.org/wiki/Fermat_polygonal_number_theorem
> For odd positive integers a and b such that b^2 < 4a and 3a < b^2 + 2b + 4
> we can find nonnegative integers s, t, u, and v
> such that a = s^2 + t^2 + u^2 + v^2 and b = s + t + u + v.



From: https://en.wikipedia.org/wiki/Hilbert_space
> The basic feature of the dot product that connects it with Euclidean geometry is that it is related to both the length (or norm) of a vector, denoted ||x||, and to the angle θ between two vectors x and y by means of the formula
> x * y = ||x|| ||y|| cos Theta



Self-Documenting Language
=========================
- Markdown compatible
- Stack machine?
    - define things like data and functions
    - arbitrary language in code blocks
        - indicate language when opening a code block
            - example:
                ```python
                1 + 1```


###### Example Program
______________________

Global_Data
===========
Comments are simply text.

Global_Data is a sequence with two elements: (1, 0)
0. 1
1. 0
___________

Function
--------
- arguments: a, b, c
- code:
    ```python

    a = a * 2
    b += Global_Data[0]
    return a + b + c```

- code:

    ```language
    1 + 1```


Commentary on Function could go here. Example uses too.
________




x^0
x^0 + x^0 + x^0
-x^0 - x^0 - x^0


1, 2, 3, ... (naturals)
-3, -2, -1, 0, 1, 2, 3, ... (integers)
3/2, -3/-2, ... (rationals)





 a     c     ad + bc
--- + --- = ----------
 b     d       bd

a(b^-1) + c(d^-1) = (bd^-1)(ad + bc)
- left expression cost: 2 inversions, 2 multiplications, one addition
- right expression cost: 1 inversion, 4 multiplications, one addition



 "Subset Inner Product Problem"
 ====================
 - Public information: A set of n elements: a, b, c, ...,
 - F:

         select a random vector X of length k using elements of the set
         select a random vector Y of length k using elements of the set
         output XY

     (Where `XY` denotes the dot product (or inner product) of X and Y)
 - How large should `n` and `k` be?
     - if `k` is too large, repeats will be selected from the set
     - log2(k) < log2(n) / 2 == k < sqrt(n)
       - Alternatively:
           - rejection sampling can ensure no duplicates
           - Pick a random binary vector of length n and weight k
           - the "random vector" is the k selected entries from the set
           - guarantees no duplicates; can use higher weight subsets
     - how large should 'n' be?
        - surely the problem is no easier than a subset-sum problem
           - n = 1024 for subset-sum problem should provide approximately 128-bit security (post-quantum)

Alternative formulation
-----------------------
- Public information: A set of n elements: a, b, c, ...
- F:

        Set B equal to a random permutation of A
        output AB

    (Where `AB` denotes the dot product)



Subset-matrix-product Problem
-----------------------------
- Public information: A set of n vectors of length k: a, b, c, ...
- F:

        create a matrix X by selecting i random vectors from the set
        create a matrix Y by selecting i random vectors from the set
        output XY

    where X * Y is the matrix product

        [a, b] * [e, f] = [ae + bg, ce + dg]
        [c, d]   [g, h]   [af + bh, cf + dh]

                 [e, g]
                 [f, h]




"Subset operation Problem"
==========================
- Generalization of subset-sum, subset-product, subset-inner product, ...
- What structure is common between them?
    - Problem has some set of public values
    - values are selected randomly from that set
        - can model this selection process as the dot product between a binary vector and the set (represented as a vector, as opposed to a "set" e.g. unordered)
    - `operation` is used to combine those values in some manner
        - the operation consumes the elements of a vector and accumulates a result
        - (f(f(a, b), c), ...)


Subset group-operation Problem
==============================
- What structure is shared between different groups (e.g. additive group, multiplicative group)















Program Metadata
================
- Name
- Type/purpose
    - application
        - system tool
            - Tools for working with the file system
            - Tools for working with pride
            - Tools for working with the OS
            - Tools for working with the hardware
        - settings
        - development/work/productivity
            - text/document editors
            - programming IDE
            - photoshop
            - audacity
        - internet
            - web browser
            - email
            - internet messenger (e.g. discord, slack)
            - applications that depend exclusively or heavily on internet in order to function
        - game
            - tactics/strategy
            - ...
        - misc
    - data/file (suggestion: use radius of the polygon/shape to indicate file size)
        - configuration file
        - database
        - movie
        - music
        - picture
        - shell script
        - source code
        - misc
    - shortcuts?
        - e.g. documents, downloads, etc
    - user-specified/custom/pinned/starred

Major split between code and data
    - use some binary state to indicate the two
        - use straight lines to indicate code and curved lines to indicate data
        - use dark colors to indicate code and light colors to indicate data
cells: 2x2 = 4
    - supports 4 different indicators of information
    - color and shape? refer to specific attributes that the
per cell:
    - color: assuming changes in increments of 16
        - 4 bits per each element in RGBA
            - (2 ** 4) ** 4 = 2 ** 16 = 65536 different possible colors
        - Can convey 16 bits of information via color
    - formula for information content: color values ** cell count
                                    - (2 ** 16) ** cell count
    - Total information with 4 cells with 2**16 possible color values per cell:
        - 18446744073709551616 possible states = 64 bits
    - shape:



does gravity cause matter to fall through the time dimension, as well as through the space dimensions
    - and beyond?
    - where does it stop influencing, and why?






x + p mod p == x
x * p mod p == 0
x ** p mod p == x
xP mod p == x





X || X == 2X mod P
k || m mod P
etc


Block0 || Block1 || ... || Blockn mod p




> totient(2^n) = 1 * 2^(n - 1)
> totient(3^n) = 2 * 3^(n - 1)
> totient(5^n) = 4 * 5^(n - 1)
> totient(7^n) = 6 * 7^(n - 1)
> totient(11^n) = 10 * 11^(n - 1)
> ...
> totient(p^n) = (p - 1) * p^(n - 1)

totient(k) = product((p - 1) * p^(k - 1))
                for p, k in factorization())






c = m + g^(k + iv) mod P
m = c - g^(k + iv) mod P

c + c = m + m + g^(k + iv) + g^(k + iv)
      = m + m + 2 * (g^(k + iv))
      = m + m + g^(k + iv + 1)

c + c + c = 3 * m + 3 * (g^(k + iv))
        ^-- needs to be brought up one level
c + c + c + c_0 = 4 * m + 4 * (g^(k + v))

decryption requires keeping track of depth


c = m * g^(k + iv)
cc = m * m * g^(k + iv) * g^(k + iv)
            g^((k + iv)^2)



c = m || (k + iv)
c + c = m + m || (k + iv) + (k + iv)
      = 2m || 2(k + iv)

c * c = m || (k + iv) * m || (k + iv)
      = (m + j(k + iv)) * (m + j(k + iv))
      = mm + mj(k + iv) + mj(k + iv) + (j(k + iv))^2
      = m^2 + 2mj(k + iv) + (jk + jiv)^2
      = m^2 || 2m(k + iv) || (jk + jiv)^2

c * c * -1 = m || (k + iv) * -1(m || (k + iv))
           = m + j(k + iv) * -1(m + j(k + iv))
           = m + j(k + iv) * (-m - j(k + iv))
           = -m^2 - mj(k + iv) - mj(k + iv) - (j(k + iv))^2

c+ * c- = m || (k + iv) + -m || (k + iv)
        = m + j(k + iv) * -m + j(k + iv)
        = -m^2 + mj(k + iv) - mj(k + iv) + (j(k + iv))^2
        = -m^2 + (j(k + iv))^2
        = -m^2 + (jk + jiv)^2
        = -m^2 + (jk + jiv) * (jk + jiv)
        = -m^2 + jk^2 + jkjiv + jkjiv + jiv^2
        = -m^2 + jk^2 + 2jkjiv + jiv^2


(a + b)(a - b)
aa + bb

c+, c- = f(m, k), f(-m, k) (alternatively: f(m, k), f(m, -k))
       = (m + ...)(-m + ...)
       = -m^2 + ...k^2...
       =  m^2 + ...k^2...

(a + k)(a + k)
aa + 2ak + kk

(a - k)(a - k)
aa - 2ak + kk


(a + b)(a + b)       0, 0
a^2 + 2ab + b^2      0, 0

(a + b)(a - b)       0, 1
aa + - bb            0, 1

(a - b)(a + b)       1, 0
aa + ab - ab - bb    1, 0

(a - b)(a - b)       1, 1
aa - ab - ab - bb
aa - 2ab - bb        1, 1



kM = M || M || ... || M

M = (m || r)
k(m || r) = (m || r) || (m || r) || ... || (m || r)









can square both sides of an equation if the signs match





ax^2 + by = c
(ax^2 + by)^2 = c^2
(ax^2 + by)(ax^2 + by) = c^2
aaxxxx + axxby + axxby + bbyy = c^2
aaxxxx + 2axxby + bbyy = c^2
a^2x^4 + 2ax^2by + b^2y^2 = c^2


ax^2 + by = c
dx^2 + ey = f

aw^2 + bz = g
dw^2 + ez = h

cw^2 + fz
w^2(ax^2 + by) + z(dx^2 + ey)
a(wx)^2 + byw^2 + dzx^2 + eyz

gx^2 + hy
x^2(aw^2 + bz) + y(dw^2 + ez)
a(wx)^2 + bzx^2 + dyw^2 + eyz



ax^2 + by = c
aw^2 + bz = d

c * w^2
w^2(ax^2 + by)
a(wx)^2 + byw^2

d * x^2
x^2(aw^2 + bz)
a(wx)^2 + bzx^2

c * d = (ax^2 + by)(aw^2 + bz)
      = aa




obfuscate function calls/indexing by creating a function/datatypes that switch the behaviors of __call__ and __getitem__





(from: https://en.wikipedia.org/wiki/Dihedral_group)
> The product of two rotations or two reflections is a rotation; the product of a rotation and a reflection is a reflection.
                  f(0, 0) -> 0        f(1, 1) -> 0                   f(0, 1) -> 1         f(1, 0) -> 1
can use rotation/reflection status to represent bits of information







g^x mod p = pq + r
             ^ what information can we gather about how q changes as x goes from 0, 1, 2, ...



public parameters:
    a set of prime numbers
    a scalar `g`
operation:
    select a subset of prime numbers
    set n = product(primes)
    output x = g mod n
problem:
    given `set of primes`, `g` and `x = g mod n`, output `n`
solution:
    g = nm + x
    g - x = nm
    factorization(g - x) = factorization(nm)
    output product(factor for factor in factorization(g - x) if factor in set)
mitigation:
    add small noise term to `n`
modified operation:
    select a subset of prime numbers
    set n = product(primes)
    output x = g mod (n + e)
problem:
    given `set of primes`, `g`, and `x = g mod (n + e)`, output `n`
solution:
    g = (n + e)m + x
    g - x = m(n + e)
    factorization(g - x) = factorization(m(n + e))
                         = factorization(m), factorization(n + e)
    problem:
        given `set of primes` and `factorization(n + e), output `n`
    solution:
        ?
problem:
    given `set of primes`, `g`, `x = g mod (n + e)`, output `n`
solution:
    g mod (n + e) = g - r mod n; r = (g / n) * e
    g - r = nm + x
    - r = nm + x - g
    -(g/n) * e = nm + x - g
    -(1/n) * e = (nm + x - g) / g

problem:
    given `set of primes`, `n + e`, output `n`






found on https://matheducators.stackexchange.com/a/17150 :

      1         1         2
    ------ + ------- = --------
    1 − t     1 + t    (1 - t^2)





given n, find a group with order n




- linear function: symmetric
- quadratic function: symmetric
    - even power functions: symmetric
- cubic function: symmetric
    - odd power functions: symmetric
- sin function: symmetric
- some combinations of the above: asymmetric

How/Why?








public parameter: P
private key: a, b < P
public key: a^2 + b^2 mod P
private key operation:
    generate secondary private key c, d
    compute secondary public key c^2 + d^2 mod P
    output secondary public key, ac - bd as 'e', ad + bc as 'f'
public key operation:
    compute third public key via (public_key * public_key_2) mod P
    if e^2 + f^2 mod P == third public key output True
    else output False
correctness:
    (a^2 + b^2) * (c^2 + d^2) = (ac - bd)^2 + (ad + bc)^2
                              = (ac + bd)^2 + (ad - bc)^2
    (brahmagupta-fibonacci identity)





for a permutation on a set of n elements, there are n! possible permutations





symbol recognition
given optimal representation of symbol to start with (e.g free of any noise)


- feedback is crucial
    - optimize for quality of feedback
- being able to score your own results is beneficial
    - need to know "correct" answer ahead of time
        - search situation

- being able to make small variations of a known-answer problem could be useful
    - e.g. take optimal representation of '0', add noise or apply transformations to it, try recognizing the noisy version
    - possible transformations:
        - add noise
        - scale/zoom
        - blur
        - skew

given a noisy thing and a set of things, determine which thing in the set the noisy thing was
    - error correcting codes?
        - could be useful for designing an alphabet of symbols that is easy to recognize
        - don't appear to be useful if the set of things is predefined?







    # x(y + 1) is x(yr + m) with r = m = 1
    # small r is amenable to scalar multiplication



E(m, k) * E(m, k) == E(m, k)^2
x = E(m, k)
x^2 mod N
given N, x^2, output x
m = isqrt(m^2)
problem: E is randomized
solution:
    - naive solution: compute `y <- E(m, k)` until y^2 == x^2
        - how many different ciphertexts for any given `m` are there?
            - depends on size of randomizing factor of cryptosystem
            - use a deterministic transformation instead?
F^-1(F(m) * F(m)) == m^2
given N, x^2 mod N, output x
m^2 = F^-1(x^2)
m = isqrt(m^2) # pretty sure this won't work unless the range of `m` is restricted


non-commutative function: F(a, b) -> b * (a * b mod p) mod q
    - commutes for small a, b
    - x * F(a, b) mod p = F(ax, b) mod p
    - 2 * F(a, b) = F(a, b) + F(a, b) = F(a, b + b mod p) mod p
        - 2 * F(a, b) \equiv F(a, b + b) mod p
    - F(a, b)^2 = F(a^2, b^2) if (ab)^2 < p
    - b^-1 * F(a, b) mod p == b^-1 * F(a, b) mod q (where inverse is defined mod p and mod q respectively)
        - c = F(a, b)

        - d = b^-1 mod q          <- inverse is generated mod q
        - d * c mod p = a mod p   <- used mod p

        - d = (b^-1) ^ 2 mod p    <- inverse is generated mod p and squared
        - a = c * d^2 mod p       <- used mod p

- do inverses exist?
    - e.g. F(F(x, y), -y) = x
           F(x, -x) = 0

one argument variant: F(a) -> a (a mod p) mod q
- F(a)F(b) = F(ab)
    - F(a)^x = F(a^x)
    - F(a)F(a) = F(a
- x^2 * F(a) = F(ax) ?


- p > q has different effect than q > p
- if p is larger than q:
    - h(x) -> x * (x mod p) mod q is equal to x^2 mod p
    - y^2 * h(x) mod p == x^2 * h(y) mod p
        - implies h(x) -> x^2 mod p
- if p is smaller than q:
    - f(x) -> x * (x mod p) mod q is not equal to x^2

b( ga mod p) mod q
y( gx mod p) mod q

a (ga mod p) mod q
x (gx mod p) mod q

ax (gx mod p) mod q
ax (ga mod p) mod q

b (b mod p) mod q
x (x mod p) mod q

bx(b mod p) mod q
bx(x mod p) mod q

bx(b mod p)


pub_a = a (a mod p) mod q
pub_b = b (b mod p) mod q

ab (b mod p) mod q = a * pub_b
ab (a mod p) mod q = b * pub_a

ab(b mod p)(a mod p)
ab(a mod p)(b mod p)
