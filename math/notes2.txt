Polar coordinates v Cartesian coordinates
=========================================


        y
        /\
        |    a
        |- -/- -
        |- / - -
    |==>|-/- - -
    |   |/ - - -
    |   0---------->x
    |          /\
    +----------||
            "basis" or "reference"

Polar coordinates
-----------------
- measurements given in (degrees, length)
- measurements given in:
   - angle between line and one axis from basis/reference
        - Is there a notion of angle between line and > one axis?
   - length of the line:
        - sqrt(x^2 + y^2) (euclidean norm, distance from 0)
- Do polar coordinates have a norm?

Cartesian coordinates
---------------------
- measurements given in (x, y)
- measurements given in:
    - length of line along one axis of the basis/reference
    - length of line along another axis of the basis/reference


Xor and And with polynomials where x > 2
========================================

- Compute exclusive-or on polynomials `x^a + x^b + x^c ...`
    - Same as when x=2, just evaluated as below:
        if a_1 == a_2:
            y^a = 0
        else:
            y^a = 1
    - Properties:
        -

- Compute `and` on polynomials
    if a_1 == a_2 and a_1 > 0:
        y_a = a_1
    else:
        y_a = 0








subset sum signature scheme
===========================

distribute set of ciphertexts as public key

sign:
    - hash message
    - use bits of hash to select elements of set to sum
    - decrypt sum
        - yields a preimage that sums to sum, but is not the hash of the message
    - distribute message/hash and alternative preimage signature `s`

verify:
    - hash message
    - check that the hash does not equal the signature
    - use bits of hash to select elements of set to sum (sum1)
    - use bits of signature to select elements of set to sum (sum2)
    - output True if sum1 == sum2







These use pickle.load(s)
- Cookie
- Google keyring
- 2to3
- bsddb







Information and Questions
====================================


there exists a set of information related to the question
there exists a subset of that information helpful in answering the question





Is there some kind of turing-equivalence notion for proof languages?
What is the smallest number of axioms you can use to prove anything any other equivalent language could prove?
Is there a hierarchy of statements/languages, where languages that can be used to prove a statement overlap (like complexity theory for proofs)




IBE
===
is it possible to securely authenticate a peer if only a username is known?
    - possible without trusted third parties ("TTPs")?
        - possible without TTPs being all-knowing?
        - possible without TTPs being a single point of failure?
        - possible without TTPs knowing what peer is authenticating what other peer?






z = sqrt(x^2 + y^2) mod P
distance from 0, mod P?









L2 Norm
=======

f(a, b) -> sqrt(a^2 + b^2)

What properties do norms have?

What shape does x = f(a, b) produce for natural numbers x?








Sampling
========

Recording
---------
- find next peak or valley
- record (absolute) max height
   - could take the point with the largest height
   - could average nearby values

Playback
--------
- take in two points from the input samples (point_a and point_b)
- repeat until all points are used:
   - push point_a onto the output stack
   - draw a curve between them and push some number of points from the curve onto the output stack
   - push point_b onto the output stack
   - set point_a = point_b
   - set point_b = next point from the input samples









Units in sums of two squares
============================
(a^2 + b^2) * (c^2 + d^2) is equal to a sum of two squares
Are there sums of two squares that are not the product of two sums of two squares?
    Do they behave as fundamental units, e.g. "primes"
        given such a "unit", can you use it to make all other elements?







The set of all information exists
The simplest operation is `copy`
    - e.g. basis of life is self-replication, an organism creating copies of itself is a pattern of information making copies of itself
- mechanisms for storage of information needed

Expressive programming language
===============================
- use case (bold, italic, normal) to indicate meaning
- =? as comparison operator?
- for name/type declaration, use:

    for a vector v, scalar s, type x, ..., :


    Class_Name
    ==========
    - attribute: value

    method_name
    -----------
    -



Pickle Investigation
====================

- Crawl repos on github for python modules
    - find places in code where pickle.load or pickle.loads are called
    - mark as potentially exploitable
        - determine if exploitable
- Create dependency tree of exploitable modules

- Check if program in dependency tree

- Determine target programs list of dependencies
    - Check if dependency

Pride
=====

auto_unschedule
---------------
- indicate which attributes are instructions that should be unscheduled upon deletion







LLL
===
LLL tends to output elements that are roughly the same size
If the value it is looking for is larger than the size of those chunks, you can break it up into pieces at the cost of adding more columns
Can you use a large enough modulus and a sufficiently small target vector to increase the number of columns needed to perform the attack to a prohibitive amount?




what is the minimal algebra that can be used for DH?
what is the simplest algebra that can be used for cryptography?
are there algebras that are too simple to use for any cryptography?
are there algebras that have too many properties for use with cryptography?





=========================
computing N! modulo N + 1

                     (1 + 2 + 3 + ... N)
- N! mod (N + 1) = g^                   mod (N + 1)
    - where g is a generator
        - a generator can be found using the factorization of N + 1

- Can test if N is prime if N + 1 can be factored in acceptable time
    - a randomly selected number is probably not a worst-case instance of the factoring problem
        - n is a factor of every n numbers
        - a randomly selected number has a 1/x chance of having x as a factor
        - probability that none of the first x numbers divide n:
            - p = 1/2 * 2/3 * 3/4 * 4/5 * ... * (x-1)/x
        - probability that at least one of the first k primes divides n:
            - 1.0 - p
- Begin factoring N and N + 1
- If factoring N finishes first, then use the factorization to determine primality
- If factoring N + 1 finishes first, then use the factorization to compute N! mod (N + 1)
- probability that neither (random) N or N + 1 have any of the first k primes as factors: 1/p^2


def prime_test(n):
    n1 = n + 1
    g = find_generator(n1)
    x = tri(n)
    if pow(g, x, n1) == 1:
        return True

def find_generator(n):
    factorization = factor_integer(n)
    g = use_factorization_to_find_generator(n, factorization)
    return g

def use_factorization_to_find_generator(n, prime_factors):
    size = int(log(n, 2) * 8)
    while True:
        candidate = random_integer(size) % n # biased, but probably fine
        for prime in prime_factors:
            b = pow(candidate, n / prime, n + 1)
            if b == 1:
                break
        else:
            #outputs = []
            #for x in range(n):
            #    gx = pow(candidate, x, n + 1)
            #    print("Testing if g^{} in outputs already".format(x))
            #    if gx in outputs:
            #        print len(set(outputs)), outputs, gx, n
            #        raise ValueError("Did not find correct generator")
            #    outputs.append(gx)
            #print("Found generator for {}".format(n))
            return candidate




# for x, y such that f(x) = y
#   draw the line from (x, 0) to (0, y)
# examine result for congruences and relationships
import pride.gui.themes
import pride.gui.gui
class Graph_Theme(pride.gui.themes.Theme):

    def draw_texture(self):
        x_offset, y_offset, x_max, y_max = self.area
        x_scalar = x_max / len(self.inputs)
        y_scalar = y_max / len(self.outputs)
        y_axis = y_offset + y_max
        line_color = self.glow_color
        draw = self.draw
        for x, y in zip(self.inputs, self.outputs):
            draw("line", x_offset + (x_scalar * x), y_axis,
                         x_offset, y_axis - (y_scalar * y),
                 color=line_color)

class Function_Graph(pride.gui.gui.window):
    defaults = {"inputs" : tuple(), "outputs" : tuple(),
                "theme_type" : Graph_Theme}


Currency that disincentives hoarding
====================================
- Design a currency that makes hoarding large amounts of money infeasible, impractical, inconvenient, and not cost-effective
    - Require significant financial investment to hold on to a unit of currency
    - Spending should be easy, convenient, and inexpensive
        - e.g. no added charges beyond the value of an item purchased (tax)


Large space requirement to hold a currency unit
-----------------------------------------------
- e.g. storing n units requires 2^n space
- Requires hardware and maintenance, or a subscription to a service that provides them
- Requires redundancy for reliable long-term storage
- Requires power
    - How does it compare to the power used by large time requirements?
- Implies large bandwidth cost to transfer a currency unit


Large time requirement to hold a currency unit
----------------------------------------------
- e.g. storing n units requires 2^n time
- Requires increasingly expensive hardware to evaluate 2^n operations in convenient time for larger n
- Requires power
    - How does it compare to the power used by large space requirements?


Value is related to density
---------------------------
- Denser currency units have a larger value/space ratio
    - Example with arbitrary values: a 1-unit requires 2^1 space (1/2 = .5), but a 10-unit requires 2^11 space (10/512 = .019)
- For a given amount of space, it is more efficient to hold lower-valued units rather than higher-valued units
    - Using the same numbers from above
        - 2^11 space could hold 11 1-units (total value: 11 * 1 = 11)
        - 2^11 space could hold  1 10-unit (total value: 1 * 10 = 10)



Chording Keyboard
=================
- Converts a normal keyboard into programmable chording keyboard
    - Pressing multiple keys simultaneously allows to select from 2^n different possible states, where n is the number of possible keys
    - Enables "pass-chords" e.g. password, passphrase, passchords
- Can make compatible with regular keyboard by simply not registering chord presses with any callback

Mode Toggle
-----------
- Press mode: pressing a key turns the state on, and releasing a key turns the state off
- Hold mode: pressing and releasing a key swaps the off/on state of the key

When is a key press registered and acted upon?
----------------------------------------------
- Normally this happens when a key is released
    - Try: When a key is released, use all currently pressed keys to determine state, then release the key
        - ignore the next release of all keys that are still pressed

    Layout
    ======
    - Put more common/helpful items in more accessible areas
    - Assuming a qwerty-layout keyboard
        Option 1
        --------
            Home Row
            --------
            - 9 Instantly accessible keys
            - asdf jkl; and the space bar
            Extended Home Row
            -----------------
            - 14 Easily accessible keys
            - Includes the characters from Home Row, plus CAPS LOCK ' and enter/return
        Option 2
        --------
        - keep fingers in constant arrangement as in asdf jkl;
            - fingers simply resting straight across
        - move up and down rows as needed, while retaining straight across arrangement of fingers
        - In one row, there are 2^9 (512) instantly accessible states

Hold keys to select a category
    - Use "sustain" key to "turn on" pressed keys, so that they stay held after being released by the operator
Press keys to select an entry in that category
    - Accumulate key presses that are held longer than x seconds
    - Act on key presses that are held less than x seconds


Analog table look-up
====================
- use transformer to implement a key:value lookup


Are key:value stores "complete"?
================================
- Can you use them to implement any function


Sequences
===================
- A sequence X is an ordered collection of data
    - f(i), f(j), ..., f(k)
    - X_i, X_j, ..., X_k
- The length of a sequence X is denoted |X| and is equal the number of samples in the sequence
- Two sequences are equivalent if |X| == |Y| and X_i == Y_i for all i
- A subsequence of X is a sequence Y such that X_i == Y_0, X_(i+1) == Y_1, ..., X_(i+j) == Y_|Y| for 0 < i < |X|
    - X contains Y
    - Y is in X
        X = 0 1 2 3 4 5 6 7 8 9
        Y = 0 1 2 3 4
        Z = 5 6 7 8 9
        Y is a subsequence of X
        Z is a subsequence of X

Operations and their relations
------------------------------
- Concatenation X || Y
    - Example:
        X = 0 1 2 3
        Y = 4 5 6 7 8 9
     X||Y = ___________
          = 0 1 2 3 4 5 6 7 8 9
    - non-commutative
        - equivalent to X + (Y * 2^k)
    - There exist A, B such that A || B != B || A
        - Property still occurs in some quantity of A, B of a given length (what quantity?)
    - Inverse: Slice

- Slice X[x:y] for sequence X and (optional) scalars x, y
    - If x is not specified, x=0 is implied
    - If y is not specified, y=|X| is implied
    - returns the subsequence X_i for i in range(x, y)
    - Example:
            X = 0 1 2 3
            Y = 0 1 2 3 4 5 6 7 8 9
       Y[|X|:]= ___________________
                4 5 6 7 8 9
    - X[:-|Y|] removes the last |Y| entries from X
        - X[:-|Y|] is the inverse of X || Y


- X % Y = X_i for all i if X_i != Y_i else 0
    - |X % Y| = |X|
- X ?? Y is equal to the number of times the sequence Y appears in X
- X / Y is equal to X with all copies of the subsequence Y removed
        (X || Y || Y || Z || Y || Z) / Y
      =  X || Z || z
    - Y is a factor of X if Y is a subsequence of X
- X ?? y for a sequence X and scalar y is equal to X + X + ... + X, for y terms
        X_0, ..., X_|X|, X_0, ..., X_|X|, X_0, ..., X_|X|  ...
              1                2                3
- X * Y for two sequences X, Y is equal to X_0 + Y + X_1 + Y + ... + X_|X| + Y
    - interleaves copies of Y into samples of X
- XY for two sequences X, Y is equal to X_0 + Y_0 + X_1 + Y_1 + ... + X_|Y| + Y_|Y| + X_(|Y| + 1) + ... + X_|X|
    - interleaves samples of Y into samples of X
#- The weight of a sequence X is the number of non-zero entries in X
#    - |X_i for all i if X_i != 0|

Polynomial Equivalent operations
----------------------
- A sequence X can be represented by a polynomial of the form
        2^(w*0)*X_0 + 2^(w*1)*X_1 + 2^(w*2)*X_2 + ... 2^(w*i)*X_|X|
        a^0 * X_0 + a^1 * X_1 + a^2 * X_2 + ... + a^|X| * X_|X|
  where w is the word size of the alphabet
    - or numerical base
        - "A sequence X can be represented by a polynomial of the form

            w = w^0, w^1, ... w^i
            s = s_0, s_1, ..., s_i
            X = dot_product(s, w)
              = (s_0 * w^0) + (s_1 * w^1) + ... + (s_i * w_i)

            where:
                - `w` is for "width", the number base or the size of the set of all symbols in the alphabet
                    - The w vector provides the "shape", it aligns the symbols of the sequence one after another with no overlap
                - 's' is for "symbols"
                    - The s vector provides the elements of the sequence
                - The dot_product takes the elements of the

- Sum X + Y is equal to X_0 + Y_0, X_1 + Y_1, ... X_min(|X|, |Y|) + Y_min(|X|, |Y|)
        X = 0 0 0 0 4 5 6 7 8 9
        Y = 0 1 2 3
         X+Y = ___________________
            0 1 2 3 4 5 6 7 8 9

- Difference X - Y is equal to X_0 - Y_0, X_1 - Y_1, ..., X_min(|X|, |Y|), Y_min(|X|, |Y|)
    X = 0 1 2 3 4 5 6 7 8 9
    Y = 0 0 0 0 4 5 6 7 8 9
      -____________________
      = 0 1 2 3

- X_i * y for an element of a sequence X_i and a scalar y is equal to the product of the value of X_i with y
- X * y for a sequence X and scalar y is equal to X_0 * y, X_1 * y, ..., X_|X| * y
- X_i * Y for an element of a sequence X_i and a sequence Y is equal to
        (a^i * X_i) * (a^0 * Y_0 + ...  + a^|Y| * Y_|Y|)
         (a^i * a^0 * X_i * Y_0) + (a^i * a^1 * X_i * Y_1) + ... + (a^i * a^|Y| * X_i * Y_|Y|)
- X * Y for two sequences X, Y is equal to  X_0 * Y, X_1 * Y, ..., X_|X| * Y
(x^2y + x^1z)(x^2a + xb)


- Length |X| = log(X, b), for a base

The concatenation operation
---------------------------
- concatenation, denoted by `X || Y`, is a function on two sequences that outputs one sequence
    - |(X || Y)| = |X| + |Y|
        - The length of the concatenation of X and Y is equal to the length of X plus the length of Y
        -
    `f(X, Y) -> X + (w^|X| * Y)`

where `'0'` denotes the "zero" sequence

    `w^|X|` is the

    `shift = |X|`

- forms a group?
    - inverse element:
        (X || Y) || -Y = X + (w^|X| * Y) + (w^|X| * (-1 * Y)) = X
    - if Y == X, then the operation is commutative
    - if Y != X, then the operation is non-commutative


Compress
--------
- Look for all identical sequences of length |input|/2 ... 1
    - Store sequence:occurrences pairs
    - store f(i), ..., f(j) in the common data section
    - push an index to the sequences location in the common data section onto the data stack section
- Look for sequences










"Has the property of" rather than "is"
======================================





ROL with modular arithmetic
===========================
rotate_left(x, k, n, b): (x / b^k) + (x * b^(n - k))
rotate_right(x, k, n, b): (x * b^k) + (x / b^(n - k))
- x: number to be rotated
- k: shift magnitude, the amount of rotation
- n: word size, the number of points on the regular n-gon
- b: number base, binary, ternary, octal, decimal, hex, etc
    - only examined with b=2 so far

- Can you use this to actually track rotation about a circle rather than using it to do bitwise rotation?
- Can you use bitwise rotation to efficiently track rotation about a circle?

- Application to group theory?
    a = g^x mod p
    g^(x + 1) mod p == rotate_left(a, 1, p, g)
        - faster to multiply by g than to use rotate_left
        - g^x * g = rotate_left(g^x, 1, p, g)
                  = (x / b^k) + (x * b^(n - k)) # substitute definition of rotate_left
                  = (x / g^1) + (x * g^(p - 1)) # substitute parameter names and values (k->1, n->p, b->g)
                  = (x / g) + (x * 1)           # substitute g for g^1, 1 for g^(p - 1)
                  = x/g + x
                  = x(1/g + 1)






Solve discrete logarithm problem by solving subset product
==================================
- Discrete logarithm problem: Given, g, P, g^x mod P, output x
- x = (a_k * 2^k) + (a_k-1 * 2^(k-1)) + ... + (a_0 * 2^0)
    - where a is a vector with coefficients in (0, 1)
- Given the set g^(2^k), g^(2^(k-1)), ..., g^(2^0) and target g^x, output the vector a
- Difficulty is determined by:
    - the size of `x`
        - determines the number of elements in the set
        - private exponent may be selected as much smaller than size of the group (e.g. 256 bits)
    - weight(a) (number of non-zero entries in the target vector a)
        - determines the number of elements in the subset
        - is centered around k / 2
    - density?
        - For the subset sum problem, density is defined as
            number of elements in the set
            -----------------------------
              log2(largest item in set)
        - Density very near 1.0 makes the problem hard
            - Low and High density instances can be solved easily

        -(Unsure) In this case, density = k/log2(g^(2^k))
            - For a 256-bit exponent:
                - k = 256
                - g=2 implies log2(largest item in set) = 2^k?
                - k/(2^k) is extremely small?
            - log2(g^(2^k)) is probably log2(P) sized
                - if P is 2048 bits, then density = 256/2048 = .125
                - if P is 1024 bits, then density = 256/1024 = .250
    - https://cstheory.stackexchange.com/a/36155/53055

        > The meet in the middle approaches that work in subset sum and k-sum should also work here with slight modifications.
        > It can be solved in O~(nm/2) by constructing two lists L1 and L2 where L1 is all possible products from first m/2 lists and L2 is all possible products for last m/2 lists.

- Difficulty: O(2^(log2(x)/4)) ?
    - log2(x) / 2 is the worst-case weight of x
        - if weight is larger, then the subset inverse-product problem can be solved instead, where the operator is replaced with the operators inverse (e.g. subset sum -> subset difference)
    - log2(x) / 4 is the worst-case weight of x, divided by two
        - division by two from partitioning/meet in the middle attack ?
    - O(2^(256 / 4)) == O(2^64)


Determine function from a sequence
==================================
- e.g. (1, 3, 5, 7, ...)
    - easy for humans to extrapolate that the sequence is "increasing odd numbers"
        - f(x) -> 0x + 1
    - Given a sequence, what process will determine a function that generates it?
        - Take difference of successive entries



"Natural" Norm
==============
- for a vector v
- f(v) = vector whose elements represent the distance from v_i to the closet natural (or integer) number
    - k_i = |round(v_i) - v_i|
        - 0 <= k_i <= 1/2
            - k_i = 0 if v_i is an natural (or integer)
            - k_i = 1/2 if v_i = x + 1/2 = (x + 1) - 1/2
- norm = max(f(v))
- if norm = 0, then all entries in v are natural (or integer) numbers


Group Theory, The Regular n-gon, and weight-1 binary words modulo 2^n
================================================
- A group of order n can be represented by a regular n-gon
- An element of that group can be represented by a vertice (point) on that n-gon
    - This perspective is equivalent to a weight 1 binary sequence modulo 2^(n)
        - The vertice representing the group element is equivalent to a '1' bit
        - The vertices not representing the group element are equivalent to '0' bits
    - The "increment" group operation is equivalent to the rotation of a weight-1 binary word modulo 2^n
        - e.g. g * g = g^(1 + 1) = g^2
    - The "decrement" group operation is equivalent to the opposite rotation of a weight-1 binary word modulo 2^n
        - e.g. g * 1/g = g^(1 - 1) = g^0 = 1
    - Could alternatively select edges (lines) instead of vertices to use as representation; there are equal number of both in a regular n-gon

Possibly useful:
----------------
- From wikipedia https://en.wikipedia.org/wiki/Regular_polygon:
    - For a regular n-gon inscribed in a unit-radius circle:
        - the product of the distances from a given vertex to all other vertices (including adjacent vertices and vertices connected by a diagonal) equals n

    - For a regular convex n-gon, each interior angle has a measure of:
        - 180(n - 2) / n degrees
        - (n - 2)/2n turns

- Can you tile a the regular n-gon into some other shape that is convenient for analysis?




Do comparisons use short-circuit evaluation? e.g.:

    def greater_than(x, y):
        for index, x_bit in enumerate(x):
            y_bit = y[index]
            if x_bit:
                if not y_bit:
                    return True
            elif y_bit:
                return False
        return False

    - If so, can this be used to mount a timing attack?









          X   Y   Z   T   ...
velocity
position
spin
repulsion











psuedo 3d via point perspective
-------------------------------
place 4 vanishing points at 0, 90, 180, 270 degrees (every 1/4 turn of a circle)
set field of view to (initial, initial + increment)
    - e.g. initial = 0
    - increment controls number of selectable points
        - #points = 90/increment

mouse motion on the selected axis rotates the field of view by increasing or decreasing the values of the field of view








**import** module **for** methods
=========================
- Syntax:
    ```python
import module for method, constant, variable, ...
import module for *```

- specifies which content from the module will actually be used
- not allowing access to other content could be enforced
    ```python
import module for x
module.y # raises Exception```
- accessing other content can be assumed not to happen
    - can import only the content that is used and store it locally






> given a,b,c ∈ N, determine whether ax^2 + by − c = 0 has a solution x,y ∈ N

- is an NP-Complete problem
- from https://cstheory.stackexchange.com/a/14147/53055

ax^2 + by − c = 0
ax^2 + by = c

m := b
r := a

rx^2 + my = c





Distributive search through all combinations of expressions
===========================================================
- generate or select an expression
    - generate finds a new expression to evaluate for relationships
        for function_number, variables, operators in zip(isequence, all_variable_combinations, all_operator_combinations):
            function = form_expression(variables, operators)
            yield function_number, function
    - or can generate a new combination at random
        - useful for exploring larger and more complex expressions
    - generate combinations of pre-existing expressions:
        for function_number, expressions, operators in zip(isequence, all_expression_combinations, all_operator_combinations):
            function = form_expression(expressions, operators)
            yield function_number, function
            # a real function_number will need a more complex format to distinguish between different entries from different generators that share a given expression_number

    - select examines an already known expression from storage
        - retrieve from storage (e.g. database, distributed hash table, etc)

- search for expressions by specifying relations and constraints
    - query storage for all expressions with a given relation

- analyze an expression to determine what properties it has
    - try applying all known (relevant) interfaces first, in order of most common
        - finds already known structure s(e.g. groups) relatively quickly
    - is there a way to start without relying on built-in known properties?
        - What is a property?
            - A statement involving variables that can be evaluated to obtain a binary conclusion
            - e.g. (from https://en.wikipedia.org/wiki/Group_(mathematics) )
                - Closure: For all a, b in G, the result of the operation, a • b, is also in G

                    def closure(f, all_element_pairs_generator, G):
                        for a, b in all_element_pairs_generator:
                            if f(a, b) not in G:
                                return False
                        return True

                - Associativity: For all a, b and c in G, (a • b) • c = a • (b • c).

                    def associativity(f, all_element_triplets_generator, G):
                        for a, b, c in all_element_triplets_generator:
                            if f(f(a  b), c) != f(a * f(b * c)):
                                return False
                        return True
                - etc
        - How to generate properties?
            - Generate increasingly complex combinations of statements from qualifiers, functions, and in(equality(ies))
                - for x, y, z in set_generator
                - there exists x, y, z
                - such that ...boolean_statement... (and) ...boolean_statement...
                    - example boolean_statement: f(a, b) in G

        - How to prune redundant properties?
            - some properties might be the same as another, just in a different form
            - when a new relation is discovered, see if it is equivalent to any other relations
                - would need to be done periodically


- search for relationships that are implied by the composition of combinations of known relations
    - e.g. "all objects that have property a and b have property c"
           "there is no object that has property c and not have properties a, b"


Expressions as Sequences
========================
- examine/define expressions e.g. `a + b = c` in terms of Sequences
    - Sequence: sum((b^i) * symbol for i, symbol in enumerate(expression))
        - symbol is the natural number encoding of an element in an alphabet or language
        - b is the base, that represents the size of the alphabet |alphabet|
            - The size of the alphabet is the number of symbols it contains




Slideshow background
====================
randomly select pictures from somewhere and display them as a slideshow
    - e.g. wikipedia (wikimedia?)



Are there objects that do not possess a given relation as a whole, but a significant subset of such objects does possess that relation?
    - e.g. The concatenation function f(x, y) is non-commutative in general, but becomes commutative when y = x






Qualities of Music
==================

Primary
-------
- a sequence of tones and/or chords
- rhythm
- Primary qualities mostly determine what "being the same song" means


Secondary
---------
- volume
- tempo
- sequence
- staccato
- legato
- tapping
- swells
- arpeggio
- Effects in general
- Secondary qualities determine the qualities of a given instance of a piece of music


"Intrinsic" versus "Extrinsic" aspects of music
===============================================
- The intrinsic qualities of a piece of music are:
- Intrinsic qualities are "stored"
    - "determined at compile time"



- The extrinsic qualities of a piece of music are:
    - variations in:
        - it's a noisy universe, there will always be some deviation from exact, though it may be small
        - Every instance of a given piece will always be unique from every other instance
            - small chance for noise to cancel out
- Extrinsic qualities occur while the piece is being played
    - "determined at runtime"










except Exception from ...
=========================

    except Exception from interaction_regarding_name:
        # "interaction_regarding_name" e.g.:
        #   a[b]
        #   a(b)

    except KeyError from "self._value_map[value]":

    except Exception from callable
    except Exception from object








"Length" and "Angle" (or "Length" and "Trig" ? ) (or "Ruler" and "Compass" ? )
====================
- a + b(i^(x mod k))
    - a is the length of a straight line
    - bi^(x mod k) is the angular or phase component
        - b is the radius of the curve
        - i^(x mod k) is the phase
            - `i` is the phase unit
            - `k` is the number of equally spaced points on the edge of a circle
                - k = 4 is the "imaginary unit" used with "complex numbers"
                - larger `k`s provide "higher resolution"
            - x is a point on the edge of a circle
            - (x mod k) is a finite ... group? ring? field?
- "Complex numbers" seem to be able to










What attack models exist, and when/why are they relevant
========================================================
- Note: This section currently only discusses encryption and confidentiality
    - There are other attack models for authentication, integrity, MACs, and digital signatures

Attack models
-------------
- An attack model specifies what abilities and information the adversary is assumed to have access to

Indistinguishability
--------------------
- Models the










Good Ideas
==========
- Users post ideas that they think are good, but will not have time/resources to realize on their own
- Different categories of ideas (e.g. software, games, story ideas)
    - Should have a dedicated humor category/tag
- Users vote on the quality of ideas
- Users can discuss, comment on, and make suggestions to improve a given idea
- "Implementations" page that shows examples of people who took the idea and realized it
    - Can vote on the quality of an implementation


Cop Rank
========
- "Social credit" score to motivate officers to pursue peaceful, non-violent solutions that help the people they interact with
- After an interaction with a police officer(s), the participating parties submit a review of their experience with the officer(s)
    - + points for positive interactions
        - Motivation: Rewards for being a good officer?
    - - points for negative interactions
        - Motivation: Aversion towards being a notorious police officer
        - e.g. murder of civilians garners an extreme amount of negative points


n-tau, The Shape Constant
=========================
- generalization of 2pi to regular n-gons
    - n-tau = perimeter / diameter
    - infinity-tau = pi



p^2 = 24n + 1
if sqrt(24n + 1) is a natural number, is it necessarily prime?
    - No; see primalitytest3.py







Symbolic Solving Strategies
===========================
- set expression equal to zero
- factor the expression if possible
    - x^2 - y^2 = (x + y) * (x - y)
    `0 = x^2 - 1
       = (x + 1) * (x - 1)
       = (x^2 - x + x - 1)
       = (x^2         - 1
       = x^2 - 1


        x^2 - 4               = x^2 - y^2
        (x + 2) * (x - 2)     = (x + y) * (x - y)
        (x^2 - 2x + 2x - 4)   = (x^2 - xy + xy - y^2)
        (x^2 - 4)             = (x^2 - y^2)
- linearize terms
- re-write variables in terms of other variables
    - if gcd(a, b) > 1, ax + by = ax + acy = a(x + cy)
    - x = (y * 2^k) + z  (break into two pieces; the most-significant and least-significant bits)



Could a polynomial-cost SAT solver be used to learn information about the structure of existence?



What is the cost of solving a subset-sum problem over an elliptic curve?




public information:
  - The generator: G
  - The sequence: 2^0, 2^1, ..., 2^n
  - The sequence: 2^0 G, 2^1 G, ..., 2^n G (multiply prior sequence by G)
      - Referred to as "the set"
  - x = 2^i, 2^j, ..., 2^k
      - alternatively written as: 2^i + 2^j + ... + 2^k
      - alternatively written as the inner product of 2^0, 2^1, ..., 2^n with i, j, ..., k where {i, j, k in (0, 1)}
      - Referred to as "the subset" or "the solution vector"
  - x G = (2^i + 2^j + ... + 2^k)G
goal:
  - Given x G, output x
  - Given the set, find a subset that sums to x G
  - Given the set as a vector `a` (e.g. `a = sorted(the set)`) and the inner product `y = a*x` find the binary vector `x`
      - The inner product of two vectors is denoted *






From: https://en.wikipedia.org/wiki/Additive_number_theory#Additive_number_theory

> For example, Vinogradov proved that every sufficiently large odd number is the sum of three primes,
> and so every sufficiently large even integer is the sum of four primes.
> Hilbert proved that, for every integer k > 1, every nonnegative integer is the sum of a bounded number of k-th powers.

From: https://en.wikipedia.org/wiki/Goldbach%27s_conjecture

> Every even integer greater than 2 can be expressed as the sum of two primes.
> Every integer greater than 5 can be written as the sum of three primes.

From: https://en.wikipedia.org/wiki/Fermat_polygonal_number_theorem
> For odd positive integers a and b such that b^2 < 4a and 3a < b^2 + 2b + 4
> we can find nonnegative integers s, t, u, and v
> such that a = s^2 + t^2 + u^2 + v^2 and b = s + t + u + v.



From: https://en.wikipedia.org/wiki/Hilbert_space
> The basic feature of the dot product that connects it with Euclidean geometry is that it is related to both the length (or norm) of a vector, denoted ||x||, and to the angle θ between two vectors x and y by means of the formula
> x * y = ||x|| ||y|| cos Theta



Self-Documenting Language
=========================
- Markdown compatible
- Stack machine?
    - define things like data and functions
    - arbitrary language in code blocks
        - indicate language when opening a code block
            - example:
                ```python
                1 + 1```


###### Example Program
______________________

Global_Data
===========
Comments are simply text.

Global_Data is a sequence with two elements: (1, 0)
0. 1
1. 0
___________

Function
--------
- arguments: a, b, c
- code:
    ```python

    a = a * 2
    b += Global_Data[0]
    return a + b + c```

- code:

    ```language
    1 + 1```


Commentary on Function could go here. Example uses too.
________




x^0
x^0 + x^0 + x^0
-x^0 - x^0 - x^0


1, 2, 3, ... (naturals)
-3, -2, -1, 0, 1, 2, 3, ... (integers)
3/2, -3/-2, ... (rationals)





 a     c     ad + bc
--- + --- = ----------
 b     d       bd

a(b^-1) + c(d^-1) = (bd^-1)(ad + bc)
- left expression cost: 2 inversions, 2 multiplications, one addition
- right expression cost: 1 inversion, 4 multiplications, one addition



 "Subset Inner Product Problem"
 ====================
 - Public information: A set of n elements: a, b, c, ...,
 - F:

         select a random vector X of length k using elements of the set
         select a random vector Y of length k using elements of the set
         output XY

     (Where `XY` denotes the dot product (or inner product) of X and Y)
 - How large should `n` and `k` be?
     - if `k` is too large, repeats will be selected from the set
     - log2(k) < log2(n) / 2 == k < sqrt(n)
       - Alternatively:
           - rejection sampling can ensure no duplicates
           - Pick a random binary vector of length n and weight k
           - the "random vector" is the k selected entries from the set
           - guarantees no duplicates; can use higher weight subsets
     - how large should 'n' be?
        - surely the problem is no easier than a subset-sum problem
           - n = 1024 for subset-sum problem should provide approximately 128-bit security (post-quantum)

Alternative formulation
-----------------------
- Public information: A set of n elements: a, b, c, ...
- F:

        Set B equal to a random permutation of A
        output AB

    (Where `AB` denotes the dot product)



Subset-matrix-product Problem
-----------------------------
- Public information: A set of n vectors of length k: a, b, c, ...
- F:

        create a matrix X by selecting i random vectors from the set
        create a matrix Y by selecting i random vectors from the set
        output XY

    where X * Y is the matrix product

        [a, b] * [e, f] = [ae + bg, ce + dg]
        [c, d]   [g, h]   [af + bh, cf + dh]

                 [e, g]
                 [f, h]




"Subset operation Problem"
==========================
- Generalization of subset-sum, subset-product, subset-inner product, ...
- What structure is common between them?
    - Problem has some set of public values
    - values are selected randomly from that set
        - can model this selection process as the dot product between a binary vector and the set (represented as a vector, as opposed to a "set" e.g. unordered)
    - `operation` is used to combine those values in some manner
        - the operation consumes the elements of a vector and accumulates a result
        - (f(f(a, b), c), ...)


Subset group-operation Problem
==============================
- What structure is shared between different groups (e.g. additive group, multiplicative group)















Program Metadata
================
- Name
- Type/purpose
    - application
        - system tool
            - Tools for working with the file system
            - Tools for working with pride
            - Tools for working with the OS
            - Tools for working with the hardware
        - settings
        - development/work/productivity
            - text/document editors
            - programming IDE
            - photoshop
            - audacity
        - internet
            - web browser
            - email
            - internet messenger (e.g. discord, slack)
            - applications that depend exclusively or heavily on internet in order to function
        - game
            - tactics/strategy
            - ...
        - misc
    - data/file (suggestion: use radius of the polygon/shape to indicate file size)
        - configuration file
        - database
        - movie
        - music
        - picture
        - shell script
        - source code
        - misc
    - shortcuts?
        - e.g. documents, downloads, etc
    - user-specified/custom/pinned/starred

Major split between code and data
    - use some binary state to indicate the two
        - use straight lines to indicate code and curved lines to indicate data
        - use dark colors to indicate code and light colors to indicate data
cells: 2x2 = 4
    - supports 4 different indicators of information
    - color and shape? refer to specific attributes that the
per cell:
    - color: assuming changes in increments of 16
        - 4 bits per each element in RGBA
            - (2 ** 4) ** 4 = 2 ** 16 = 65536 different possible colors
        - Can convey 16 bits of information via color
    - formula for information content: color values ** cell count
                                    - (2 ** 16) ** cell count
    - Total information with 4 cells with 2**16 possible color values per cell:
        - 18446744073709551616 possible states = 64 bits
    - shape:



does gravity cause matter to fall through the time dimension, as well as through the space dimensions
    - and beyond?
    - where does it stop influencing, and why?






x + p mod p == x
x * p mod p == 0
x ** p mod p == x
xP mod p == x





X || X == 2X mod P
k || m mod P
etc


Block0 || Block1 || ... || Blockn mod p




> totient(2^n) = 1 * 2^(n - 1)
> totient(3^n) = 2 * 3^(n - 1)
> totient(5^n) = 4 * 5^(n - 1)
> totient(7^n) = 6 * 7^(n - 1)
> totient(11^n) = 10 * 11^(n - 1)
> ...
> totient(p^n) = (p - 1) * p^(n - 1)

totient(k) = product((p - 1) * p^(k - 1))
                for p, k in factorization())






c = m + g^(k + iv) mod P
m = c - g^(k + iv) mod P

c + c = m + m + g^(k + iv) + g^(k + iv)
      = m + m + 2 * (g^(k + iv))
      = m + m + g^(k + iv + 1)

c + c + c = 3 * m + 3 * (g^(k + iv))
        ^-- needs to be brought up one level
c + c + c + c_0 = 4 * m + 4 * (g^(k + v))

decryption requires keeping track of depth


c = m * g^(k + iv)
cc = m * m * g^(k + iv) * g^(k + iv)
            g^((k + iv)^2)



c = m || (k + iv)
c + c = m + m || (k + iv) + (k + iv)
      = 2m || 2(k + iv)

c * c = m || (k + iv) * m || (k + iv)
      = (m + j(k + iv)) * (m + j(k + iv))
      = mm + mj(k + iv) + mj(k + iv) + (j(k + iv))^2
      = m^2 + 2mj(k + iv) + (jk + jiv)^2
      = m^2 || 2m(k + iv) || (jk + jiv)^2

c * c * -1 = m || (k + iv) * -1(m || (k + iv))
           = m + j(k + iv) * -1(m + j(k + iv))
           = m + j(k + iv) * (-m - j(k + iv))
           = -m^2 - mj(k + iv) - mj(k + iv) - (j(k + iv))^2

c+ * c- = m || (k + iv) + -m || (k + iv)
        = m + j(k + iv) * -m + j(k + iv)
        = -m^2 + mj(k + iv) - mj(k + iv) + (j(k + iv))^2
        = -m^2 + (j(k + iv))^2
        = -m^2 + (jk + jiv)^2
        = -m^2 + (jk + jiv) * (jk + jiv)
        = -m^2 + jk^2 + jkjiv + jkjiv + jiv^2
        = -m^2 + jk^2 + 2jkjiv + jiv^2


(a + b)(a - b)
aa + bb

c+, c- = f(m, k), f(-m, k) (alternatively: f(m, k), f(m, -k))
       = (m + ...)(-m + ...)
       = -m^2 + ...k^2...
       =  m^2 + ...k^2...

(a + k)(a + k)
aa + 2ak + kk

(a - k)(a - k)
aa - 2ak + kk


(a + b)(a + b)       0, 0
a^2 + 2ab + b^2      0, 0

(a + b)(a - b)       0, 1
aa + - bb            0, 1

(a - b)(a + b)       1, 0
aa + ab - ab - bb    1, 0

(a - b)(a - b)       1, 1
aa - ab - ab - bb
aa - 2ab - bb        1, 1



kM = M || M || ... || M

M = (m || r)
k(m || r) = (m || r) || (m || r) || ... || (m || r)









can square both sides of an equation if the signs match





ax^2 + by = c
(ax^2 + by)^2 = c^2
(ax^2 + by)(ax^2 + by) = c^2
aaxxxx + axxby + axxby + bbyy = c^2
aaxxxx + 2axxby + bbyy = c^2
a^2x^4 + 2ax^2by + b^2y^2 = c^2


ax^2 + by = c
dx^2 + ey = f

aw^2 + bz = g
dw^2 + ez = h

cw^2 + fz
w^2(ax^2 + by) + z(dx^2 + ey)
a(wx)^2 + byw^2 + dzx^2 + eyz

gx^2 + hy
x^2(aw^2 + bz) + y(dw^2 + ez)
a(wx)^2 + bzx^2 + dyw^2 + eyz



ax^2 + by = c
aw^2 + bz = d

c * w^2
w^2(ax^2 + by)
a(wx)^2 + byw^2

d * x^2
x^2(aw^2 + bz)
a(wx)^2 + bzx^2

c * d = (ax^2 + by)(aw^2 + bz)
      = aa




obfuscate function calls/indexing by creating a function/datatypes that switch the behaviors of __call__ and __getitem__





(from: https://en.wikipedia.org/wiki/Dihedral_group)
> The product of two rotations or two reflections is a rotation; the product of a rotation and a reflection is a reflection.
                  f(0, 0) -> 0        f(1, 1) -> 0                   f(0, 1) -> 1         f(1, 0) -> 1
can use rotation/reflection status to represent bits of information







g^x mod p = pq + r
             ^ what information can we gather about how q changes as x goes from 0, 1, 2, ...



public parameters:
    a set of prime numbers
    a scalar `g`
operation:
    select a subset of prime numbers
    set n = product(primes)
    output x = g mod n
problem:
    given `set of primes`, `g` and `x = g mod n`, output `n`
solution:
    g = nm + x
    g - x = nm
    factorization(g - x) = factorization(nm)
    output product(factor for factor in factorization(g - x) if factor in set)
mitigation:
    add small noise term to `n`
modified operation:
    select a subset of prime numbers
    set n = product(primes)
    output x = g mod (n + e)
problem:
    given `set of primes`, `g`, and `x = g mod (n + e)`, output `n`
solution:
    g = (n + e)m + x
    g - x = m(n + e)
    factorization(g - x) = factorization(m(n + e))
                         = factorization(m), factorization(n + e)
    problem:
        given `set of primes` and `factorization(n + e), output `n`
    solution:
        ?
problem:
    given `set of primes`, `g`, `x = g mod (n + e)`, output `n`
solution:
    g mod (n + e) = g - r mod n; r = (g / n) * e
    g - r = nm + x
    - r = nm + x - g
    -(g/n) * e = nm + x - g
    -(1/n) * e = (nm + x - g) / g

problem:
    given `set of primes`, `n + e`, output `n`






found on https://matheducators.stackexchange.com/a/17150 :

      1         1         2
    ------ + ------- = --------
    1 − t     1 + t    (1 - t^2)





given n, find a group with order n




- linear function: symmetric
- quadratic function: symmetric
    - even power functions: symmetric
- cubic function: symmetric
    - odd power functions: symmetric
- sin function: symmetric
- some combinations of the above: asymmetric

How/Why?








public parameter: P
private key: a, b < P
public key: a^2 + b^2 mod P
private key operation:
    generate secondary private key c, d
    compute secondary public key c^2 + d^2 mod P
    output secondary public key, ac - bd as 'e', ad + bc as 'f'
public key operation:
    compute third public key via (public_key * public_key_2) mod P
    if e^2 + f^2 mod P == third public key output True
    else output False
correctness:
    (a^2 + b^2) * (c^2 + d^2) = (ac - bd)^2 + (ad + bc)^2
                              = (ac + bd)^2 + (ad - bc)^2
    (brahmagupta-fibonacci identity)





for a permutation on a set of n elements, there are n! possible permutations





symbol recognition
given optimal representation of symbol to start with (e.g free of any noise)


- feedback is crucial
    - optimize for quality of feedback
- being able to score your own results is beneficial
    - need to know "correct" answer ahead of time
        - search situation

- being able to make small variations of a known-answer problem could be useful
    - e.g. take optimal representation of '0', add noise or apply transformations to it, try recognizing the noisy version
    - possible transformations:
        - add noise
        - scale/zoom
        - blur
        - skew

given a noisy thing and a set of things, determine which thing in the set the noisy thing was
    - error correcting codes?
        - could be useful for designing an alphabet of symbols that is easy to recognize
        - don't appear to be useful if the set of things is predefined?







    # x(y + 1) is x(yr + m) with r = m = 1
    # small r is amenable to scalar multiplication



E(m, k) * E(m, k) == E(m, k)^2
x = E(m, k)
x^2 mod N
given N, x^2, output x
m = isqrt(m^2)
problem: E is randomized
solution:
    - naive solution: compute `y <- E(m, k)` until y^2 == x^2
        - how many different ciphertexts for any given `m` are there?
            - depends on size of randomizing factor of cryptosystem
            - use a deterministic transformation instead?
F^-1(F(m) * F(m)) == m^2
given N, x^2 mod N, output x
m^2 = F^-1(x^2)
m = isqrt(m^2) # pretty sure this won't work unless the range of `m` is restricted


non-commutative function: F(a, b) -> b * (a * b mod p) mod q
    - commutes for small a, b
    - x * F(a, b) mod p = F(ax, b) mod p
    - 2 * F(a, b) = F(a, b) + F(a, b) = F(a, b + b mod p) mod p
        - 2 * F(a, b) \equiv F(a, b + b) mod p
    - F(a, b)^2 = F(a^2, b^2) if (ab)^2 < p
    - b^-1 * F(a, b) mod p == b^-1 * F(a, b) mod q (where inverse is defined mod p and mod q respectively)
        - c = F(a, b)

        - d = b^-1 mod q          <- inverse is generated mod q
        - d * c mod p = a mod p   <- used mod p

        - d = (b^-1) ^ 2 mod p    <- inverse is generated mod p and squared
        - a = c * d^2 mod p       <- used mod p

- do inverses exist?
    - e.g. F(F(x, y), -y) = x
           F(x, -x) = 0

one argument variant: F(a) -> a (a mod p) mod q
- F(a)F(b) = F(ab)
    - F(a)^x = F(a^x)
    - F(a)F(a) = F(a
- x^2 * F(a) = F(ax) ?
- properties apply only for small a, b (ab < p ?)


- p > q has different effect than q > p
- if p is larger than q:
    - h(x) -> x * (x mod p) mod q is equal to x^2 mod p
    - y^2 * h(x) mod p == x^2 * h(y) mod p
        - implies h(x) -> x^2 mod p
- if p is smaller than q:
    - f(x) -> x * (x mod p) mod q is not equal to x^2

b( ga mod p) mod q
y( gx mod p) mod q

a (ga mod p) mod q
x (gx mod p) mod q

ax (gx mod p) mod q
ax (ga mod p) mod q

b (b mod p) mod q
x (x mod p) mod q

bx(b mod p) mod q
bx(x mod p) mod q

bx(b mod p)


pub_a = a (a mod p) mod q
pub_b = b (b mod p) mod q

ab (b mod p) mod q = a * pub_b
ab (a mod p) mod q = b * pub_a

ab(b mod p)(a mod p)
ab(a mod p)(b mod p)


F(a) = a^2 - a*p*r (mod q)
     (ab)^2 - apr - bps
     (ab)^2 - p(ar - bs)

a^2 - apr = a(a - pr)




p
for all a: a = pq + r
rewrite all variables in terms of p

ax + e mod p

(pq + r)(ps + t) + (pu + v) mod p
ppqs + pqt + prs + rt + pu + v
ppqs + pqt + prs + pu + rt + v
p(pqs + qt + rs + u) + rt + v = pq(ps + t) + p(rs + u) + rt + v
                              = p(q(ps + t) + (rs + u)) + rt + v
                              = pz + rt + v
                                     if rt + v < p, pz + rt + v mod p = rt + v
                                     r, t, v are all p-sized. Some rt + v will be larger than p, others smaller


public vector x
secret permutation matrix K (alternatively, secret invertible matrix)
public key operation:
    Kx * x
where a * b is the inner product between two vectors a and b, and Kx is the matrix product of K with x
example:

     x = 3,   some vector
         10,
         7,
         11

     K = [0, 1, 0, 0]   transposition matrix
         [1, 0, 0, 0]
         [0, 0, 1, 0]
         [0, 0, 0, 1]

           3 10  7 11
     Kx = [0, 1, 0, 0] -> 10     shuffles the vector
          [1, 0, 0, 0] -> 3
          [0, 0, 1, 0] -> 7
          [0, 0, 0, 1] -> 11

     Kx * x = 3   10   7  11     dot product
             10    3   7  11
             30 + 30 + 14 + 22 = 60 + 26 + 86

(a * u) + (a * v) = (ax + by + cd + ...) + (ar + bs + ct + ...)  (where * is inner product as above and + integer addition)
                  = a(x + r) + b(y + s) + c(d + t)
F(K, x) -> x * Kx
        -> x * r
F(K, x) + F(J, x) = (x * Kx) + (x * Jx)
                  =  (x * r) + (x * s)
                  =  x * (r + s)        = F(K + J, x) where + is entry-wise addition
n * F(K, x) -> F(n * K, x)   (right * means multiply each element of K by the value n)

F(K, x) * F(J, x) = (ax + by + cz) * (aq + br + cs)
                  = ax(aq + br + cs) + by(aq + br + cs) + cz(aq + br + cs)

F(K, x) + F(K, y) = (ax + by) + (cw + dz)

F(K, x + y) = (a + c)x + (b + d)y
            = ax + cx + by + dy

F(K, x * y) = acx + bdy    where * is element-wise multiplication

longer vector -> larger matrix
vector of bits
    test the hamming weight to ensure K is not used on low-weight or specially crafted states

y * F(K, x) = F(K, x * y)     where x * y is the application of the scalar y to the elements of the vector x
                              and y * F(K, x) is the scalar multiplication of y with the value F(K, x)

y * F(K, x) = F(K, x) + F(K, x) + ...

    F(K, x) + F(K, x) + ...     ; F(K, x) + F(J, x) -> F(K + J, x)
    F(K + K + ..., x)
    F(K * y, x)

y * F(K, x) = F(K * y, x) = F(K, x * sqrt(y))
y^2 * F(K, x) = F(K, x * y)


properties:
    F(K, x) + F(J, x) = F(K + J, x)
    y * F(K, x) = F(K * y, x) = F(K, x * y)



 1     1     a + b           f(a, b)   additive group operation
--- + --- = ------
 a     b      ab             g(a, b)   multiplicative group operation



 1     1    g^(a + b)
--- * --- = ----------      ?
g^a   g^b    g^ab


               g^(a + b)
g^-a * g^-b = ---------- ?
                g^ab


         1     1      2x
F(x) -> --- + --- = -------  mod p
         x     x      x^2

F is a bijection, an invertible permutation of elements mod p
F is an involution, `F(F(x)) = x`
F(x) * F(y) = F(x) if x * y equiv 2x mod p
F(x) * F(y) = F(xy / 2)
F(x) = 2/x




 Strange behavior in python
 ==========================

     x = range(8)
     x[:] = (x for x in range(8))
     print x


    # variables used in a list comprehension can be referred to afterwards
    [x for i, x in enumerate(iterable)]
    assert i == len(iterable) - 1
    assert x == iterable[-1]



 Given:
 - public prime modulus p
 - assumed known/chosen message m in (0, 1)
 - fixed uniformly random value x mod p
 - per-message uniformly random r such that 2r <= p - 1

    x(2r + m) mod p

 is almost uniformly random mod p

 How many plaintext-ciphertext pairs are required to break the scheme?











    0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17   ... = infinite vector `v`
    0  0  1  1  0  1  0  1  0  0  0   1   0   1   0   0   0   1    ... = infinite binary vector `p`

    define: bprime(k) -> The smallest subsequence of `p` that has weight k

Find a function that generates bprime(k)
    - Easy!

    > The Berlekamp–Massey algorithm is an algorithm that will find the shortest linear feedback shift register (LFSR) for a given binary output sequence.
    > The algorithm will also find the minimal polynomial of a linearly recurrent sequence in an arbitrary field.

(from https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm )

    - (side note: Can we use this algorithm on micks shortest superstring problem?)

The polynomial so obtained does not have to predict the position of any primes larger than those it came from

- What can we do with these polynomials?
- What properties do they have?
- How do the polynomials change as k increases?






Focused sunlight
================
Use a parabolic reflector or a lens to focus light to a point

Light welding
-------------
- Focus lens/parabola into receiving end of fiber optic cable
- Point output end of cable towards area to be welded
- The heat from the light melts the metal
    - probably the fiber cable too!

Creating buildings from sand and sunlight
-----------------------------------------
- Could create houses in a desert by using focused sunlight to fuse sand into glass
- Sand would be a relatively cheap and abundant building material
- Could conceivably also include rocks/metals/materials if available and necessary (for strength, chip resistance, etc)
- Create construction materials of a given form (a post, a wall, etc) by dumping sand into a template and fusing it
- Easily fix chipped/broken areas by dumping sand and sunshine on it

Stellar forge
-------------
- Focused sunlight on a massive scale
- Giant reflector in space
- Focuses huge amount of sunlight to an area
- Creates extremely high temperature (and who knows what other weird side effects)?
- Useful for joining/creating materials that require incredible temperature

Interstellar beacon/lighthouse
------------------------------
- Direct an anomalous or detectable amount of sunlight towards a given direction in the universe
- Create a universal compass?
    - Send out lines in all basic directions
    - Travel along the light beam
- Use the light beam for propulsion?
    - Focused light solar sail?
- Universal internet
    - think of all the alien kitty cat pictures!
    - Bad news: ping would be *terrible*


General-purpose energy source (heat)
------------------------------------
- Myriad of ways to turn heat into useful energy

What would happen if a star were to enclosed by a spherical parabolic reflector?
    - All light would be reflected towards a point at the center of the star





Reeds-Sloane (generalized Berlekamp-Massey) algorithm
-----------------------------------------------------
- note: Will abbreviate as SRA as opposed to RSA to minimize confusion

    > Find shortest linear recurrence that can generate a sequence ... (where elements of the sequence are integers mod m)



Given some expression `H(G(F(a, b), c), ...)` e.g. `a + b * c + d`, it can be viewed as a data vector and an operation (or code) vector

          (((a + b) * c) + b)
    data     0   1    2    1  = [0, 1, 2, 1]
    code       0    1    0    = [0, 1, 0]


         F(G(F(a, b), c), b)
    data       0  1   2  1   = [0, 1, 2, 1]
    code 0 1 0               = [0, 1, 0]


(N_1(x), x=0) = SRA(natural numbers)
(N_2(x), x=0) = SRA(even natural numbers)
(N_3(x), x=1) = SRA(odd natural numbers)  ?N3 might be N2 just offset by one?
(N_square(x), x=0) = SRA(squares)






(g^x mod p, x=) = SRA( g^(g^(g^x)...) )   *can evaluate knowing only g, p, g^x mod p




Given a set of rules and a goal to optimize, many learning algorithms will find ways to cheat around the rules.
Can we rely on and employ this behavior instead of viewing it as an undesirable side effect?
    - Can we generate AI whose purpose is finding ways to skirt around some given rules?
        - Can we use this to improve a set of rules and make them "tight" to where they cannot be gamed/cheated anymore?



given: m, m2, m3
randomly select `w` and note that:
    m = w + x
    m2 = x + y
    m3 = y + z
c = f(inverse_ft(w, x, y, z), k)

given: m
randomly generate `ri` such that:
    m = r0 + r1 + r2 + ...
c = f(inverse_ft(r0, r1, r2, ...), k)
      inverse_ft(r0, r1, r2, ...) + k
      inverse_ft(r0, r1, r2, ...) * k
      inverse_ft(r0, r1, r2, ...) ? k


higher degree variant of autoproduct
given: S = a, b, c, d, e

    v0 = S
    v1 = permutation(S) # stop here and it is the regular autoproduct
    v2 = permutation(S)
    v3 = permutation(S)
    ...
    output = dot_product(v0, v1 * ...) where `vx * vy` indicates a vector whose contents are the element-wise product vx_0 * vy_0, vx_1 * vy_1, ...

amount of information in (v1, v2, v3, ..., vn): |S|!^n



Autoproduct with public matrix and secret vector

    F(G, k) -> Gk * k
    k = a, b, c, d
    Gk = c, b, a, d
    Gk * k = c b a d
             a b c d
             ac + bb + ac + dd

    k2  = e, f, g, h
    Gk2 = g, f, e, h
    Gk2 * k2 = e f g h
               g f e h
               eg + ff + eg + hh


             aa + bb + cc + dd
             ab + bc + cd + ad
             ac + bd + ca + bd
             ad + ba + cb + cd


Autoproduct-like where the shuffled vector is entry-wise added to the input vector, and the product of that vector is the output

product(element for element in Pv + v)

v = a, b

(a + b)(a + b)deeeeeeeeeeeeeeeeevvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvewwwww
(a + a)(b + b)

Keep the matrix and the vector fixed
Add a third argument for a short vector

    M = permutation matrix
    g = public vector
    s = secret random short vector

    v = entrywise_product(g, s)                      ax, by, cz
    v = Mv                    Matrix multiplication  cz, by, ax
    output g * v              Dot product         acxz + bbyy + acxz = 2axcz + bbyy
                              Anti-dot product




Can the autoproduct be used for a key agreement scheme?
=======================================================

Idea 1
------
- Public random permutation matrix 'K`
- private key: X = x * K (entry-wise product of scalar with elements of a matrix)
- public key = F(X, G) (autoproduct)
- shared secret = x * F(Y, G)
    - correctness comes from the identity `n * F(K, x) -> F(n * K, x)`
- problem: F(X, G) = x * F(K, G)
    - easy to divide by F(K, G) since it is public information
- solution:
    - change one term so that the relation is still mostly true
    - make it slight larger

Idea 2
------
- Public random permutation matrix `K`
- private key:

    generate random x
    set X = x * K; (entry-wise product of scalar with elements of a matrix)
    set X[0][i] += e  (addition of `e` to the value at position where K[0][i] == x)
    output e

- public key: F(X, G) (autoproduct)
- shared secret: msb(e * F(Y, G))


- make one of the coefficients in the autoproduct matrix slighter larger than the others
    - makes the msb stick out above others
        - or maybe not, depending on the number of carries (determined by dimension) and how much larger the coefficient is made








  x      x mod (p - 1) = x mod (qrs...) = crt(x mod q, x mod r, x mod s, ...)
g^   = g^                                                                     mod P




Discrete convolution operator/cellular automaton
=============================
For each cell in the automaton, "soak up" values from nearby points that have sufficient value to distribute

- No action when a cell and its neighbors all have the same value
    - require difference in value for propagation
    - uniform neighborhoods remain stable and do not change for some time
- Conservation of sum(|value| for value in values)
    - A point has sufficient value to distribute if `abs(point value) >= number of points neighbors`
- For every action, there is an equal and opposite reaction
    - if `1` is taken from the center and distributed to the left cell, a `1` is also taken from the center and distributed to the right cell
    - (see example below)
- Can also work in dimensions smaller/larger than 2
- should it be allowed to take a maximum of 1 value per neighbor per update?
    - e.g. if a cell has the value `k=64`, the neighbors could absorb 8 points each
    - should the number of points absorbed per update be limited or not?
- adding value to a cell does not have an immediate effect (no change until `k > n`)

Example (Moore neighborhood)
----------------------------


    0   0   0         1   1   1        0   0   0

    0   8   0     ->  1   0   1    ->  0   8   0

    0   0   0         1   1   1        0   0   0


Neighborhoods
-------------
- Choice of neighborhood determines number of neighbors
- Moore neighborhood consists of the points in the square-oid around the target point
- Von Neumann neighborhood consists of the points adjacent to the target point

    0  0  0      0  1  0
    0  4  0  ->  1  0  1
    0  0  0      0  1  0


Boundary vs no boundary
-----------------------
A boundary implies that edges and corners will have fewer neighbors than points in the middle do.
    - Values do not "wrap around" at the edges
No boundary implies a finite but endless automaton (e.g. a sphere, torus, etc)
    - Values "wrap around" at the edges


Viewing the transformation with linear algebra
-----------------------------------
What is the linear algebra transformation that performs the following mapping?
`k` indicates the value of the center cell (in the example, `k = 8`)
`n` indicates the number of neighbors in the neighborhood (2d moore neighborhood `n = 8`)

    0   0   0         1   1   1

    0   8   0     ->  1   0   1

    0   0   0         1   1   1


    0   0   0         0   0   0

    0  k<n  0     ->  0   k   0

    0   0   0         0   0   0




    0   0   0          |  k/n       k/n        k/n|
                       |                          |
    0   k   0    +     | k/n    -(n * (k/n))   k/n|  = ...
                       |                          |
    0   0   0          |  k/n       k/n        k/n|


                   (   | 1/n        1/n         1/n|)
                   (   |                           |)
                 + (k *| 1/n   -(n * (k/n))/k   1/n|)  = ...       # extra / k term in middle cancels out scaling by k
                   (   |                           |)
                   (   | 1/n        1/n         1/n|)



                       |  8/8       8/8        8/8|
                       |                          |
        ...        +   | 8/8    -(8 * 8/8)     8/8|  = ...
                       |                          |
                       |  8/8       8/8        8/8|


                       | 1       1      1|
                       |                 |
        ...        +   | 1      -8      1|  = ...
                       |                 |
                       | 1       1      1|


Optimization
------------


        n1        n2       n3

        n4        n5       n6

        n7        n8       n9


Each `n` is a 3x3 neighborhood
The collection above of such n can also be viewed as a 3x3 neighborhood
Replace each neighborhood with the sum of the values in its cells
Apply discrete convolution to the matrix so obtained

Can be used to estimate larger scale value changes in less time than evaluating all of the cells individually
    - is only an approximation
        - implicitly assumes/requires that each `ni` neighborhood be relatively uniform in its values
            - deviation from this assumption results in lower accuracy








Computing primorial mod k to compute n! mod k

11!

1   2   3   4   5   6   7   8   9   10    11


                            2
            2               2
1   2   3   2   5   2   7   2   9   2    11    How many 2s?

bottom row: 5 = 11 / 2 = 11 / 2^1
second row: 2 = 11 / 4 = 11 / 2^2
top row: 1    = 11 / 8 = 11 / 2^3 = 11 / 2^x where 2^x < n
total: 8
              = (n / 2^1) + (n / 2^2) + (n / 2^3)
              = (n / p^1) + (n / p^2) + ... + (n / p^x)

            (n/p^i > 0)
              Sigma    (n / p^i)
      n          i
   Product    p^
      p


2
2
2
2
2  3
2  3
2  3  5
2  3  5  7

Accumulate primorial(7) mod n      # accumulate multiplies the stored product by the operand
Accumulate primorial(5) mod n
Accumulate primorial(3) ** 2 mod n
Accumulate 2 ** 4 mod n
Output result



Given k * (2*r + m) mod P
where:
    - P is a prime number
    - k is a persistent secret uniformly random mod P and is invertible mod P
    - r is an ephemeral secret uniformly random in some range Q and has some constant factor y
        - In the example above, the constant factor y=2, i.e. r is even
    - m is a public, potentially adversarially controlled, bit in (0, 1)

What is the cost of obtaining any of `k, r, m` given `k * (2*r + m)`?
How many samples are required?
How does the number of required samples change as the size of `r` decreases and the size of y increases?







single form linearization ("monomorphic linearization")
-------------------------------------------------------
For all n, p:

    n = (p * q) + r

for: some q
     some r < p


Rewrite any/all terms:

    ax + by    (arbitrary expression)

in terms of a single variable `p`:

    ax = pq + r
    by = ps + t

    ax + by = pq + r + ps + t = p(q + s) + r + t = pu + v










              .

           .     .

      .   -      -   .
    .                  .
      .   -      -   .

          .      .

             .

x^2 + 4(x(x + 1) / 2)
x^2 + 2(x(x + 1)
x^2 + 2x(x + 1)
x^2 + 2x^2 + 2x
3x^2 + 2x





Can get MSB(d) via modular_inverse(e, (n & upper_bits) + 1)
The least significant bit of d is 1 because d must be odd as it is coprime to the totient

>>> p
73759451544113484607788934619926785385530373967988168487873669857444050985719L
>>> q
27246121825720763563663761721328265745241721034895383907971358153565129016037L
>>> n
2009659002569263488397899443904890452555744659601185475238515677069177008097241041082324165434462810005656169542597667163014723303356379810345638408975603L
>>> t
2009659002569263488397899443904890452555744659601185475238515677069177008097140035508954331186291357309314914491466895068011839750960534782334629228973848L
>>> d
1339772668379508992265266295936593635037163106400790316825677118046118005398093357005969554124194238206209942994311263378674559833973689854889752819315899L
>>> d3 = modular_inverse(e, ((n >> 258) << 258) + 1) # zero out lsb, except for 1 (d must be odd)
1339772668379508992265266295936593635037163106400790316825677118046118005397997308273733884034697531261053634179426086320278123293223669984263741229760513L
>>> e
3

assert (((e * d3) - 1) * d3) % t ==  -((k - (e * k * k))) % t

# y = -ek^2 + k = ek^2 + k        # -k^2 = k^2
                = kke + k
                = k(ke + 1)

# solve quadratic equation for y?


guess at factors of totient
what is the cost of guessing the easy factors of the totient
    - "easy" factors are of the form `p^x` for a prime `p` smaller than some bound
    - k = upper limit on number of primes to test for
        - e.g. k=256 means only look for primes that are less than 256
        - factors are k-easy if they are smaller than the bound k
    - How many factors are there?
        - the sum of the exponents of the factors
            - 4 * 9 = 2^2 * 3^2
                       (2 +   2) = 4
        - alternatively: count the number of items in the "expanded" factorization:
            - "expand" the factorization p1^x, p2^y, ... into p1, p1, p1, ..., p2, p2, p2, ...
                - 4 * 9 = 2^2 * 3^2 = 2 * 2 * 3 * 3
                                      1 + 1 + 1 + 1 = 4
        - denote by #f(n) the number of factors of n
    - How may factors are there on average?

    - Can prune values that are multiples of `e`
        - e must be coprime to the totient

    - The more factors there are, the smaller they must be for a given size

    - What is the probability of the totients factorization including a given prime `p`?
        - p is a factor of `1/p` numbers
            - there is a `1/p` chance that a given number is divisible by `p`
        - Given that `p` is a factor of `t`, what is the probability that q is also a factor of `t`
            - 1/p * 1/q = 1/pq
    - The chance that n has one of the first k primes as a factor tends towards `L=~94-95%` as k grows
        - Given that `n` has one of the first k primes as a factor, what is the chance that it has a second prime factor < k?
            - L ** 2
        - What is the chance that `n` has `x` prime factors that are less than `k`
            - L ** x

- Find the totient `t` by guessing its factors
- Compute d' = modular_inverse(e, (n - lower_bits) + 1)
    - msb(d') == msb(d)
- Guess the totients easy factors
    - build a list/table of all numbers with k-easy factorization for some value k
    - amenable to pre-computation and parallelization
- For each number `i` in the list:
    - find the largest `x` such that `log2(ix) = log2(t)`
    - option 1: set d" = modular_inverse(e, n + ix) and check if m^e^d = m mod n for some m
        - if yes, output d'' and/or ix
    - option 2: factor `ix`?
        - (p - 1) and (q - 1) still have at least one non-easy factor each
        - end up with another hard factorization problem of slightly smaller size




(p - 1)(q - 1) = pq - p - q + 1
               = (2ab)(2cd)
               = 4abcd










        0000
        0000
        0000
        0000

        ^ work on one column at a time; set bits to maximize difference between rows
          assume each column should have half of the bits set
             - is this actually optimal? do good codes necessarily have that feature?
          use distinct pattern in each column


        0000    0000   0010    0011
        0000    0100   0110    0110
        1000    1100   1100    1100
        1000    1000   1000    1001
        ^        ^       ^        ^

        possible sequences (written here as rows, but used in the columns above):
            0000    unusuable due to hamming weight
            0001    unusuable
            0010    unusuable
            0011    used in column 3
            0100    unusuable
            0101
            0110    used in column 2
            0111    unusuable
            1000    unusuable
            1001    used in column 4
            1010
            1011    unusuable
            1100    used in column 1
            1101    unusuable
            1110    unusuable
            1111    unusuable

        usable values: 0011 0101 0110 1001 1010 1100
        used values:   0011      0110 1001      1100
            - 3 values are simple rotations of the same value
            - replace 0110 and 0011 with the more distinct 0101 and 1010

         0000   0000   0010   0011
         0000   0100   0100   0100
         1000   1000   1010   1010
         1000   1100   1100   1101



public key : K = a^2 + b^2
private key: a, b
sign:
    X = x^2 + y^2
    r = h(X || m)
    R = r^2 + r^2
    signature = X, c, d such that c^2 + d^2 = K * S * R
     = (a^2 + b^2) * (x^2 * y^2) * (r^2 + r^2)         # expand terms
     = ((ax - by)^2 + (ay + bx)^2) * (r^2 + r^2)       # brahmagupta-fibonacci identity
     = (j^2 + k^2) * (r^2 + r^2)                       # rename terms
     = (jr - kr)^2 + (jr + kr)^2                       # brahmagupta-fibonacci identity
       (jr - kr), (jr + kr) = c, d                     # knowing a, b, x, y, r, allows computation of c, d
    output S
verify:
    r = h(X || m)
    R = r^2 + r^2
    S = K * X * R
    if c^2 + d^2 == S:
        output True
    else:
        output False



https://en.wikipedia.org/wiki/Dot_product

> the cosine of the angle of two vectors is the quotient of their dot product by the product of their lengths




Mx + x
Mx . x



F(x, y) ->     1/x + 1/y = (x + y)/xy


 1     1      k + m
--- + --- = ----------
 k     m       km

e * F(k, m) = e/k + e/m
e * F(k, l) = e/k + e/l
                         +
              e/k + e/k + e/m + e/l
              2(e/k) + e/m + e/l
              2k + m + l


 e * F(k, m) = e/k + e/m
 e * F(k, l) = e/k + e/l
                         *
               e(1/k + 1/m) * e(1/k + 1/l)
               ee(1/k + 1/m)(1/k + 1/l)
               (1/k + 1/m)(1/k + 1l)
            (k + m)     (k + l)
            -------  * ---------
              km          kl

            (k + m)(k + l)  = kk + kl + km + ml = kk + k(l + m) + ml
            --------------
                kkml



E(k, m) -> c = 1/k + 1/(k + m) = k + k + m / k(k + m)
D(k, c) -> m = 1/(c - 1/k) - k




add positive/negative coefficient choice to autoproduct

    F(M, x) . x = sum (s[i] * Mx[i] * x[i])
        where:
            M is a square matrix
                - random permutation
                    - random "permutation" with small random scalars per row
                - random invertible matrix
            x is a vector
            s is a vector with elements in the set (1, -1)
                - indicates the sign (positive/negative) for each place

adds n bits of uncertainty, where n is the dimension of the vector or matrix rows/columns
amount of uncertainty present in random permutation variant:

    n! * 2^n




c = e(xr + 1/m) = exr + e/m        for x=n^2 and 1/m is mod n

2c = 2e(xr + 1/m) = 2exr + 2e/m
2c / e = 2(xr + 1/m) = 2xr + 2/m
(2c / e) mod x = 2/m      if 2/m < n










(er + m)^-1 mod P

where:

    secret:
        secret prime P
        e, r are uniformly random ~sqrt(P)
    public:
        m < x
        er + m < P


(1/er + m) + (1/er + m) = er + m + er + m = 2(er + m)
                         ----------------- -----------
                          (er + m)(er + m)   (er + m)^2


(1/er + m)(1/er + m) = 1/x * 1/x = 1/x^2 = 1/(er + m)(er + m) = (er)^2 + 2erm + m^2




ax^2 + by = c     agcd-style symmetric cipher
                  plus autoproduct


powers of x for the vector in the autoproduct

    x^(a + b) + x^(c - d) + ...




if x is prime and x + 2 is prime, then x + 1 = 6n


a^2 = 24b + 1             for prime a >= 5
a^2 - 1 = 0 mod 24

(x + 2)^2 - 1 = 0 mod 24
xx + 4x + 4 - 1 = 0 mod 24
xx + 4x + 3 = 0 mod 24
xx + 4x = 21 mod 24


x     = sqrt(24b + 1)
x + 2 = sqrt(24c + 1)



x^2 + 1 = (x + i)(x - i)













Autoproduct based cipher

Data
----

- Fixed secret signed permutation matrix `K`
    - Inverse matrix `I`
- Fixed vector `g`
- Mostly random vector `v`
    - The last coefficient is non-random
        - It is equal to the message minus the sum of the other coefficients
- Plaintext integer `m`
- Public prime modulus `P`

Operators
---------
- `Kv` indicates the product of the matrix `K` with the vector `v`
- `v . g` indicates the dot product between the vectors `v` and `g`

Encrypt
-------
Find a random vector `v` such that

        Kv . g = m  mod P

And output `v` as the ciphertext.

How to find such a `v`
----------------------
Rewrite:

        Kv . g = m

as:

        v' . g = m


How to generate v'?

- Pick random `v''` of length `len(v') - 1`. Augment `v''` with a final coefficient `(m - v'' . g[:-1]) / g[-1]`

How to turn `v'` into `v`?

        v' = Kv
        Iv' = IKv = v


Costs
-----
Ciphertexts require `n * log(P)` bits of space.





Cantors diagonal method and the Missing Vector Problem
------------------------------------------------------
Given a set of n dimensional vectors:

    - Partition the set into |set| / n square matrices
    - Use the diagonal method on each matrix to obtain an n-dimensional vector that is not an element of the matrix
    - Check if the vector is a vector in the lattice







  1
----- + e  = (k + r)^-1 + e = c
k + r

           k
k * c = ------- + ke
         k + r


(k + r) = (sqrt(k) + sqrt(r)i) * (sqrt(k) - sqrt(r)i)
        = k - sqrt(kr)i + sqrt(kr)i - ri^2
        = k + r



3 = 2^1.5

There are 3^n possible vectors of length n with coefficients in (-1, 0, 1)
There are 3^(n^2) possible n-dimensional matrices consisting of such vectors



(s * a) . b = s * (a . b) = a . (s * b)

Guess:

    For a scalar s = a . b, if x | s, then x | a_i for all a_i in a
                                        or x | b_i for all b_i in b

clearly untrue in general:
    - suppose a and b both consist of prime numbers
    - a . b is a integer scalar and must have a factorization
        - factors of that scalar cannot divide every element of such vectors because they are necessarily coprime
    - The factors of the scalar are hidden among the factors of the output of the dot product
        - The factors of s are hidden among the factors of a . b

But there do exist vectors where this relation holds. Constructing one is trivial.






Water slingshot
========================================

Basic concept
-------------
Fill a deep basin with water.
Invert a cup or bowl so that the hole faces down, towards the water.
Push the inverted vessel straight downwards into the water.
Upon release, the air trapped in the vessel will force it to shoot towards the surface.

Larger scale
------------
Construct a tunnel to the floor of a large body of water

    - The ceiling of (part of) the tunnel is the floor of the body of water

Construct a vessel launching facility

    - Construct a space suitable for the preparation and launching of vessels

Launch mechanism:

    - Construct a vertical pipe with sealed ends through to the floor
    - Insert vessel into pipe from the underground launching facility
    - Seal pipe ends
    - Pump pressurized gas into vessel
    - Open pipe end that is exposed to the water
        - pipe will fill with water
    - If the effect works as advertised, then the gas in the vessel will force it to shoot towards the water surface.




Solving autoproducts implies ability to solve subset sum problems
=================================================================
    - F(K, g) -> x
        - (square) Matrix K (various forms) of dimensions NxN
        - vector g of dimension N
        - scalar x

Subset sum problem
------------------
Given:

    - a scalar y
    - a vector of integers S
    - an autoproduct solving oracle O
        - given a scalar x and (implicitly) a vector g, outputs a matrix K (of suitable form) in polynomial time

find the binary vector b such that:

        S . b = y

Solution:

    - For each coefficient s in S, invoke the oracle O on s to obtain some K'. Create a list of these matrices (a tensor)
        - Denote this list of matrices as T
    - Invoke the oracle on y to obtain Y
        - Y is an NxN matrix that is a subset sum of the coefficient matrices (the K' in the table)
        - The solution vector is the same solution vector from the initial problem
        - Each coefficient of Y Y_ij is a subset sum of coefficients from the entries of T matrices.

            Y_ij = sum(K'_ij for each K in T)

    - Each coefficient of Y coupled with T provides additional independent equations with the same solution vector.
        - Results in NxN (N^2) additional equations
    - Set oracle to target a matrix of size N = sqrt(|S|)



from https://www.youtube.com/watch?v=3gjJDuCAEQQ&list=UUpCSAcbqs-sjEVfk_hMfY9w&index=7 :

> ... the magnitude plot tells you how large the areas are ... when put through the pythagorean theorem
> ... the phase plot ... tells you relatively how big one area is compared to the other, as well as if either of them are negative.
> Fourier transform scans for sinusoidals, the Laplace transform scans for exponentials








Autoproduct-like function that only requires group homomorphism
===============================================================

    F(v: vector, s: scalar): (v_i * s) + (v_j * s^2) + ... + (v_n * s^k)


Random Sequence Problem
=======================
Given:
    A: vector (of dimension n)
    q: modulus
and
    A . PS mod Q
with:
    P: random permutation matrix (of dimension n)
    S: vector of the form s^1, ..., s^(n + 1) (for s uniformly random in q)
Output s

Applications
============
The homomorphism in each case is a group homomorphism.
- "weak" Homomorphic Hashing
    - "weak" means it is strong for randomly chosen inputs
- Homomorphic MAC
    - Verifiable computation
- Digital Signature
- Homomorphic (symmetric) encryption
- Key Encapsulation/Public-key encryption

Digital Signatures from Homomorphic Hashing
===========================================
Public Information:
- a weak hash function `F` such that:
        F(a) + F(b) = F(a + b)

Key Generation:
- Private key: A tuple of `k` random inputs suitable for `F`
- Public key: A tuple of `F(x)` for each `x` in the private key

Sign:




















How to programmatically enforce good coding habits
==================================================
Raise an error if any metadata is missing
    - What information?
        - author
        - license
        - date created
        - documentation
Raise an error if unit tests were not found for items declared in the API
Require the programmer to provide a reason (commit message) *before* opening a tracked file for editing





the zeros of euler's totient function:

    1 = 1!
    2 = 2!

For those sensing a pattern, the pattern does not appear to continue:

    phi(3!) = phi(2 * 3) = (2 - 1) * (3 - 1) = 1 * 2 = 2
              phi(pq)    = (p - 1) * (q - 1)



"sequence fishing"
Given:

    x
    y = ax^0 + bx^1 + ... + cx^n mod p

output a, b, ..., c

equivalently, given:

    polynomial X (x^0, x^1, ..., x^n)
    y = A . X

output A













pq = p * (p - k)
   = p^2 - pk

p^2 = 24x + 1

pq = 24x + 1 - pk
pq - 1 = 24x - pk


7 * 5 = 7 * (7 - 5)
      = 49 - (7 * 2) = 49 - 14 = 35

34 = 24x - (7 * 2) = 48 - 14   # x = 2

pq - 1 = 24x - pk
    z  = ax - by

Given:

- `z = ax - by`
- `a = 24`
- `y = (p - k)` is a multiple of 2
    - `y`

Output `b`




can get `by mod 24x` for arbitrary `x`



n          = pq
n          = pp - p(p - q)
n          = pp - py
n          = 24x + 1 - py
n - 1      = 24x - py

`x, p, y` are all unknowns.
But one can guess at `y`.

- try all `y` (integers) in increasing order
- try randomly sampled `y`
- guess prime factors of `y`
    - z is a factor of 1/z numbers
    - i.e. probability of 2 being a factor of `y` is 1/2, probability of 3 being 1/3, etc

Denoting the guess as `y'`:

n - 1      = 24x - pey'

The `p` term accrues extra unknown factors `e`, which are those factors that were not guessed.
Now there are two knowns, `24, y`.
Linearize `pe` into `p'` and there two unknowns, `x, p'`.




n          = pq
n^2        = p^2 q^2
           = (24x + 1)(24y + 1)
           = 576xy + 24x + 24y + 1
n^2 - 1    = 576xy + 24(x + y)
(n^2 - 1)
---------  = 24xy + x + y
   24

x + y mod 24


n          = pq
n^3        = n^2 * n
           = (24x + 1)(24y + 1)(24x + 1 - pk)
           = (576xy + 24(x + y) + 1)(24x + 1 - pk)
           = 13824xxy + 576xy - 576xypk + 576x(x + y) + 24(x + y) - 24pk(x + y) + 24x + 1 - pk

n          = pq
n^4        = n^2 * n^2
           = (24x + 1)(24y + 1)(24x + 1)(24y + 1)
           = (576xy + 24(x + y) + 1)(576xy + 24(x + y) + 1)
           =







Given some topological object (e.g. a lumpy potato)...
Assuming 2d for simplicity:

    - start with drawing of a circle
    - use edge select tool to select the edge of the circle
        - Inside the edge is the space occupied by the object
    - invert the selection
        - Select the space outside of the object
        - Color the object and inverse space e.g. black and white, respectively

With this inverted view, re-examine basic topological transformations from the perspective of the space rather than of the object







Finite differences and filtering out small terms from polynomials
=================================================================
Recall:

e(x) -> x

1, 2, 3
2 - 1, 3 - 2 = 1, 1                             first order difference = degree!
                                                     second order difference = 0

f(x) -> x^2


f(1), f(2), ...
1, 4, 9, 16
4 - 1, 9 - 4, 16 - 9 = 3, 5, 7                            first order difference
5 - 3, 7 - 5 = 2, 2                            second order difference = degree!
                                                      third order difference = 0
g(x) -> x^3

g(1), g(2), ...
1, 8, 27, 64, 125

8 - 1, 27 - 8, 64 - 27, 125 - 64 = 7, 19, 37, 61          first order difference

19 - 7, 37 - 19, 61 - 37 = 12, 18, 24                    second order difference

18 - 12, 24 - 18 = 6, 6                         third order difference = degree!
                                                     fourth order difference = 0

Consider:

h(x) -> x^2 + x^3

h(1), h(2), ...

2, 12, 36, 80, 150

12 - 2, 36 - 12, 80 - 36, 150 - 80 = 10, 24, 44, 70       first order difference

24 - 10, 44 - 24, 70 - 44 = 14, 20, 26                   second order difference

20 - 14, 26 - 20 = 6, 6                         third order difference = degree!
                                                     fourth order difference = 0

The x^2 terms are zeroed by the time the third order difference is arrived at.

1 + 1, 4 + 8, 9 + 27, 16 + 64, 25 + 125

12 - 2 = (8 + 4) - (1 + 1) = 8 + 4 - 1 - 1 = 8 - 1 + 4 - 1


Can use Nth order differences to eliminate terms of degree N - 1


i(x, y) -> x^2 + y^2

i(1, 5), i(2, 6), i(3, 7), i(4, 8) = 1^2 + 5^2, 2^2 + 6^2, 3^2 + 7^2, 4^2 + 8^2
                                   = 1 + 25, 4 + 36, 9 + 49, 16 + 64
                                   = 26, 40, 58, 80
40 - 26, 58 - 40, 80 - 58 = 14, 18, 22                    first order difference
18 - 14, 22 - 18 = 4, 4           second order difference (notice it != degree!)
                                                      third order difference = 0

Can filter out multiple terms of a given degree simultaneously








    V = a, b, ..., k                                                    a vector

        |a 0 ... 0|
    M = |0 b ... 0|
        |0 0 ... k|

    V is a linear combination of the rows of M


    N = x, Y, ..., z
    V . N = ax + by + ... + kz









Random pass-sentence generator
==============================
Instead of choosing from a set of words

- Choose a sentence structure (e.g. noun adjective verb)
- For each component, select a random entry from the corresponding list
    - If the component is a noun, then sample from a list of random nouns
    - If the component is a verb, then sample from a list of random verbs
    - etc
- Populate the lists with potentially humorous combinations of entries
    - A funny sentence may be easier to remember




subject action subject condition
(detail detail subject) (detail action) (detail subject) (detail condition)
